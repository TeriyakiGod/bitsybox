#ifndef TUNE_H
#define TUNE_H

char* dialog_demo_js =
	"function Dialog() {\n"
	"\n"
	"var BITSYBOX_HACK_maxPageLines = 10;\n"
	"\n"
	"this.CreateRenderer = function() {\n"
	"	return new DialogRenderer();\n"
	"};\n"
	"\n"
	"this.CreateBuffer = function() {\n"
	"	return new DialogBuffer();\n"
	"};\n"
	"\n"
	"var DialogRenderer = function() {\n"
	"	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?\n"
	"	var textboxInfo = {\n"
	"		width : 104,\n"
	"		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow\n"
	"		top : 12,\n"
	"		left : 12,\n"
	"		bottom : 12, //for drawing it from the bottom\n"
	"		padding_vert : 2,\n"
	"		padding_horz : 4,\n"
	"		arrow_height : 5,\n"
	"	};\n"
	"\n"
	"	var font = null;\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"		textboxInfo.height = (textboxInfo.padding_vert * (BITSYBOX_HACK_maxPageLines)) + (relativeFontHeight() * (BITSYBOX_HACK_maxPageLines)) + textboxInfo.arrow_height;\n"
	"\n"
	"		// todo : clean up all the scale stuff\n"
	"		var textboxScaleW = textboxInfo.width * getTextScale();\n"
	"		var textboxScaleH = textboxInfo.height * getTextScale();\n"
	"		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);\n"
	"	}\n"
	"\n"
	"	this.GetPixelsPerRow = function() {\n"
	"		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();\n"
	"	}\n"
	"\n"
	"	// todo : cache this value? it shouldn't really change in the middle of a game\n"
	"	function getTextScale() {\n"
	"		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;\n"
	"	}\n"
	"\n"
	"	function relativeFontWidth() {\n"
	"		return Math.ceil(font.getWidth() / getTextScale());\n"
	"	}\n"
	"\n"
	"	function relativeFontHeight() {\n"
	"		return Math.ceil(font.getHeight() / getTextScale());\n"
	"	}\n"
	"\n"
	"	this.ClearTextbox = function() {\n"
	"		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);\n"
	"	};\n"
	"\n"
	"	var isCentered = false;\n"
	"	this.SetCentered = function(centered) {\n"
	"		isCentered = centered;\n"
	"	};\n"
	"\n"
	"	// todo : I can stop doing this every frame right?\n"
	"	this.DrawTextbox = function() {\n"
	"		if (isCentered) {\n"
	"			// todo : will the height calculations always work?\n"
	"			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));\n"
	"		}\n"
	"		else if (player().y < (bitsy.MAP_SIZE / 2)) {\n"
	"			// bottom\n"
	"			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));\n"
	"		}\n"
	"		else {\n"
	"			// top\n"
	"			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var arrowdata = [\n"
	"		1,1,1,1,1,\n"
	"		0,1,1,1,0,\n"
	"		0,0,1,0,0\n"
	"	];\n"
	"\n"
	"	this.DrawNextArrow = function() {\n"
	"		// HACK! for bitsybox tool demo menu\n"
	"		return;\n"
	"\n"
	"		// bitsy.log(\"draw arrow!\");\n"
	"		var text_scale = getTextScale();\n"
	"		var textboxScaleW = textboxInfo.width * text_scale;\n"
	"		var textboxScaleH = textboxInfo.height * text_scale;\n"
	"\n"
	"		var top = (textboxInfo.height - 5) * text_scale;\n"
	"		var left = (textboxInfo.width - (5 + 4)) * text_scale;\n"
	"		if (textDirection === TextDirection.RightToLeft) { // RTL hack\n"
	"			left = 4 * text_scale;\n"
	"		}\n"
	"\n"
	"		for (var y = 0; y < 3; y++) {\n"
	"			for (var x = 0; x < 5; x++) {\n"
	"				var i = (y * 5) + x;\n"
	"				if (arrowdata[i] == 1) {\n"
	"					//scaling nonsense\n"
	"					for (var sy = 0; sy < text_scale; sy++) {\n"
	"						for (var sx = 0; sx < text_scale; sx++) {\n"
	"							var px = left + (x * text_scale) + sx;\n"
	"							var py = top + (y * text_scale) + sy;\n"
	"							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	};\n"
	"\n"
	"	function drawCharData(charData, textScale, top, left, width, height, color) {\n"
	"		for (var y = 0; y < height; y++) {\n"
	"			for (var x = 0; x < width; x++) {\n"
	"				var i = (y * width) + x;\n"
	"				if (charData[i] == 1) {\n"
	"					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.DrawChar = function(char, row, col, leftPos) {\n"
	"		// characters with effects need to be redrawn every frame\n"
	"		if (char.effectList.length > 0) {\n"
	"			char.redraw = true;\n"
	"		}\n"
	"\n"
	"		// skip characters that are already drawn and don't need to be updated\n"
	"		if (!char.redraw) {\n"
	"			return;\n"
	"		}\n"
	"		char.redraw = false;\n"
	"\n"
	"		var text_scale = getTextScale();\n"
	"		var charData = char.bitmap;\n"
	"		var top;\n"
	"		var left;\n"
	"\n"
	"		if (char.effectList.length > 0) {\n"
	"			// clear the pixels from the previous frame\n"
	"			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);\n"
	"			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);\n"
	"			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);\n"
	"		}\n"
	"\n"
	"		// compute render offset *every* frame\n"
	"		char.offset = {\n"
	"			x: char.base_offset.x,\n"
	"			y: char.base_offset.y\n"
	"		};\n"
	"		char.SetPosition(row, col);\n"
	"		char.ApplyEffects(effectTime);\n"
	"\n"
	"		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);\n"
	"		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);\n"
	"\n"
	"		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);\n"
	"\n"
	"		// TODO : consider for a future update?\n"
	"		/*\n"
	"		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {\n"
	"			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });\n"
	"			char.hasPlayedBlip = true;\n"
	"		}\n"
	"		*/\n"
	"\n"
	"		// call printHandler for character\n"
	"		if (!disableOnPrintHandlers) {\n"
	"			char.OnPrint();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var effectTime = 0; // TODO this variable should live somewhere better\n"
	"\n"
	"	var shouldUpdateTextboxSettings = true;\n"
	"	var shouldClearTextbox = true;\n"
	"	var shouldDrawArrow = true;\n"
	"\n"
	"	var disableOnPrintHandlers = false;\n"
	"\n"
	"	this.Draw = function(buffer, dt, disableOnPrint) {\n"
	"		disableOnPrintHandlers = (disableOnPrint === true);\n"
	"\n"
	"		// bitsy.log(\"draw dialog\");\n"
	"		if (buffer.DidFlipPageThisFrame()) {\n"
	"			shouldClearTextbox = true;\n"
	"			shouldDrawArrow = true;\n"
	"		}\n"
	"\n"
	"		effectTime += dt;\n"
	"\n"
	"		if (shouldUpdateTextboxSettings) {\n"
	"			bitsy.log(\"draw textbox\");\n"
	"			this.DrawTextbox(); // todo : rename to something more accurate\n"
	"			shouldUpdateTextboxSettings = false;\n"
	"		}\n"
	"\n"
	"		if (shouldClearTextbox) {\n"
	"			// bitsy.log(\"clear textbox\");\n"
	"			this.ClearTextbox();\n"
	"			shouldClearTextbox = false;\n"
	"		}\n"
	"\n"
	"		// bitsy.log(\"draw chars\");\n"
	"		buffer.ForEachActiveChar(this.DrawChar);\n"
	"\n"
	"		if (buffer.CanContinue() && shouldDrawArrow) {\n"
	"			// bitsy.log(\"draw next arrow\");\n"
	"			shouldDrawArrow = false;\n"
	"		}\n"
	"\n"
	"		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {\n"
	"			bitsy.log(\"page finished\");\n"
	"			onPageFinish();\n"
	"		}\n"
	"\n"
	"		// bitsy.log(\"draw dialog end\");\n"
	"	};\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var onPageFinish = null;\n"
	"	this.SetPageFinishHandler = function(handler) {\n"
	"		onPageFinish = handler;\n"
	"	};\n"
	"\n"
	"	this.Reset = function() {\n"
	"		effectTime = 0;\n"
	"		// TODO - anything else?\n"
	"\n"
	"		shouldUpdateTextboxSettings = true;\n"
	"		shouldClearTextbox = true;\n"
	"		shouldDrawArrow = true;\n"
	"	}\n"
	"\n"
	"	this.updateTextboxPosition = function() {\n"
	"		shouldUpdateTextboxSettings = true;\n"
	"	};\n"
	"\n"
	"	// this.CharsPerRow = function() {\n"
	"	// 	return textboxInfo.charsPerRow;\n"
	"	// }\n"
	"}\n"
	"\n"
	"var DialogBuffer = function() {\n"
	"	var buffer = [[[]]]; // holds dialog in an array buffer\n"
	"	var pageIndex = 0;\n"
	"	var rowIndex = 0;\n"
	"	var charIndex = 0;\n"
	"	var nextCharTimer = 0;\n"
	"	var nextCharMaxTime = 50; // in milliseconds\n"
	"	var isDialogReadyToContinue = false;\n"
	"	var activeTextEffects = [];\n"
	"	var activeTextEffectParameters = [];\n"
	"	var font = null;\n"
	"	var arabicHandler = new ArabicHandler();\n"
	"	var onDialogEndCallbacks = [];\n"
	"\n"
	"	this.SetFont = function(f) {\n"
	"		font = f;\n"
	"	};\n"
	"\n"
	"	this.SetPixelsPerRow = function(n) {\n"
	"		pixelsPerRow = n;\n"
	"	};\n"
	"\n"
	"	this.CurPage = function() { return buffer[ pageIndex ]; };\n"
	"	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };\n"
	"	this.CurChar = function() { return this.CurRow()[ charIndex ]; };\n"
	"	this.CurPageCount = function() { return buffer.length; };\n"
	"	this.CurRowCount = function() { return this.CurPage().length; };\n"
	"	this.CurCharCount = function() { return this.CurRow().length; };\n"
	"\n"
	"	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page\n"
	"		var rowCount = rowIndex + 1;\n"
	"		for (var i = 0; i < rowCount; i++) {\n"
	"			var row = this.CurPage()[i];\n"
	"			var charCount = (i == rowIndex) ? charIndex+1 : row.length;\n"
	"			// bitsy.log(charCount);\n"
	"\n"
	"			var leftPos = 0;\n"
	"			if (textDirection === TextDirection.RightToLeft) {\n"
	"				leftPos = 24 * 8; // hack -- I think this is correct?\n"
	"			}\n"
	"\n"
	"			for(var j = 0; j < charCount; j++) {\n"
	"				var char = row[j];\n"
	"				if(char) {\n"
	"					if (textDirection === TextDirection.RightToLeft) {\n"
	"						leftPos -= char.spacing;\n"
	"					}\n"
	"					// bitsy.log(j + \" \" + leftPos);\n"
	"\n"
	"					// handler( char, i /*rowIndex*/, j /*colIndex*/ );\n"
	"					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)\n"
	"\n"
	"					if (textDirection === TextDirection.LeftToRight) {\n"
	"						leftPos += char.spacing;\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.Reset = function() {\n"
	"		buffer = [[[]]];\n"
	"		pageIndex = 0;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"		isDialogReadyToContinue = false;\n"
	"\n"
	"		afterManualPagebreak = false;\n"
	"\n"
	"		activeTextEffects = [];\n"
	"\n"
	"		onDialogEndCallbacks = [];\n"
	"\n"
	"		isActive = false;\n"
	"	};\n"
	"\n"
	"	this.DoNextChar = function() {\n"
	"		nextCharTimer = 0; //reset timer\n"
	"\n"
	"		//time to update characters\n"
	"		if (charIndex + 1 < this.CurCharCount()) {\n"
	"			//add char to current row\n"
	"			charIndex++;\n"
	"		}\n"
	"		else if (rowIndex + 1 < this.CurRowCount()) {\n"
	"			//start next row\n"
	"			rowIndex++;\n"
	"			charIndex = 0;\n"
	"		}\n"
	"		else {\n"
	"			//the page is full!\n"
	"			isDialogReadyToContinue = true;\n"
	"			didPageFinishThisFrame = true;\n"
	"		}\n"
	"\n"
	"		if (this.CurChar() != null) {\n"
	"			if (this.CurChar().isPageBreak) {\n"
	"				// special case for page break marker character!\n"
	"				isDialogReadyToContinue = true;\n"
	"				didPageFinishThisFrame = true;\n"
	"			}\n"
	"			\n"
	"			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text\n"
	"		}\n"
	"	};\n"
	"\n"
	"	this.Update = function(dt) {\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"		// this.Draw(dt); // TODO move into a renderer object\n"
	"		if (isDialogReadyToContinue) {\n"
	"			return; //waiting for dialog to be advanced by player\n"
	"		}\n"
	"\n"
	"		nextCharTimer += dt; //tick timer\n"
	"\n"
	"		if (nextCharTimer > nextCharMaxTime) {\n"
	"			this.DoNextChar();\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var isSkipping = false;\n"
	"\n"
	"	this.Skip = function() {\n"
	"		bitsy.log(\"SKIPPP\");\n"
	"		isSkipping = true;\n"
	"\n"
	"		didPageFinishThisFrame = false;\n"
	"		didFlipPageThisFrame = false;\n"
	"\n"
	"		// add new characters until you get to the end of the current line of dialog\n"
	"		while (rowIndex < this.CurRowCount() && isSkipping) {\n"
	"			this.DoNextChar();\n"
	"\n"
	"			if (isDialogReadyToContinue) {\n"
	"				//make sure to push the rowIndex past the end to break out of the loop\n"
	"				rowIndex++;\n"
	"				charIndex = 0;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if (isSkipping) {\n"
	"			rowIndex = this.CurRowCount() - 1;\n"
	"			charIndex = this.CurCharCount() - 1;\n"
	"		}\n"
	"\n"
	"		isSkipping = false;\n"
	"	};\n"
	"\n"
	"	this.tryInterruptSkip = function() {\n"
	"		if (isSkipping) {\n"
	"			isSkipping = false;\n"
	"			return true;\n"
	"		}\n"
	"\n"
	"		return false;\n"
	"	};\n"
	"\n"
	"	this.FlipPage = function() {\n"
	"		didFlipPageThisFrame = true;\n"
	"		isDialogReadyToContinue = false;\n"
	"		pageIndex++;\n"
	"		rowIndex = 0;\n"
	"		charIndex = 0;\n"
	"	}\n"
	"\n"
	"	this.EndDialog = function() {\n"
	"		isActive = false; // no more text to show... this should be a sign to stop rendering dialog\n"
	"\n"
	"		for (var i = 0; i < onDialogEndCallbacks.length; i++) {\n"
	"			onDialogEndCallbacks[i]();\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var afterManualPagebreak = false; // is it bad to track this state like this?\n"
	"\n"
	"	this.Continue = function() {\n"
	"		bitsy.log(\"CONTINUE\");\n"
	"\n"
	"		// if we used a page break character to continue we need\n"
	"		// to run whatever is in the script afterwards! // TODO : make this comment better\n"
	"		if (this.CurChar().isPageBreak) {\n"
	"			// hacky: always treat a page break as the end of dialog\n"
	"			// if there's more dialog later we re-activate the dialog buffer\n"
	"			this.EndDialog();\n"
	"			afterManualPagebreak = true;\n"
	"			this.CurChar().OnContinue();\n"
	"			return false;\n"
	"		}\n"
	"		if (pageIndex + 1 < this.CurPageCount()) {\n"
	"			bitsy.log(\"FLIP PAGE!\");\n"
	"			//start next page\n"
	"			this.FlipPage();\n"
	"			return true; /* hasMoreDialog */\n"
	"		}\n"
	"		else {\n"
	"			bitsy.log(\"END DIALOG!\");\n"
	"			bitsy.textbox(false);\n"
	"			//end dialog mode\n"
	"			this.EndDialog();\n"
	"			return false; /* hasMoreDialog */\n"
	"		}\n"
	"	};\n"
	"\n"
	"	var isActive = false;\n"
	"	this.IsActive = function() { return isActive; };\n"
	"\n"
	"	this.OnDialogEnd = function(callback) {\n"
	"		if (!isActive) {\n"
	"			callback();\n"
	"		}\n"
	"		else {\n"
	"			onDialogEndCallbacks.push(callback);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	this.CanContinue = function() { return isDialogReadyToContinue; };\n"
	"\n"
	"	function DialogChar() {\n"
	"		this.redraw = true;\n"
	"\n"
	"		this.effectList = [];\n"
	"		this.effectParameterList = [];\n"
	"\n"
	"		this.color = textColorIndex; // white\n"
	"		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)\n"
	"\n"
	"		this.col = 0;\n"
	"		this.row = 0;\n"
	"\n"
	"		this.SetPosition = function(row,col) {\n"
	"			// bitsy.log(\"SET POS\");\n"
	"			// bitsy.log(this);\n"
	"			this.row = row;\n"
	"			this.col = col;\n"
	"		};\n"
	"\n"
	"		this.ApplyEffects = function(time) {\n"
	"			// bitsy.log(\"APPLY EFFECTS! \" + time);\n"
	"			for (var i = 0; i < this.effectList.length; i++) {\n"
	"				var effectName = this.effectList[i];\n"
	"				// bitsy.log(\"FX \" + effectName);\n"
	"				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);\n"
	"			}\n"
	"		};\n"
	"\n"
	"		var printHandler = null; // optional function to be called once on printing character\n"
	"		this.SetPrintHandler = function(handler) {\n"
	"			printHandler = handler;\n"
	"		};\n"
	"		this.OnPrint = function() {\n"
	"			if (printHandler != null) {\n"
	"				// bitsy.log(\"PRINT HANDLER ---- DIALOG BUFFER\");\n"
	"				printHandler();\n"
	"				printHandler = null; // only call handler once (hacky)\n"
	"			}\n"
	"		};\n"
	"\n"
	"		this.bitmap = [];\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.base_offset = { // hacky name\n"
	" 			x: 0,\n"
	"			y: 0\n"
	"		};\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	function DialogFontChar(font, char, effectList, effectParameterList) {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)\n"
	"		this.effectParameterList = effectParameterList.slice();\n"
	"\n"
	"		var charData = font.getChar(char);\n"
	"		this.char = char;\n"
	"		this.bitmap = charData.data;\n"
	"		this.width = charData.width;\n"
	"		this.height = charData.height;\n"
	"		this.base_offset.x = charData.offset.x;\n"
	"		this.base_offset.y = charData.offset.y;\n"
	"		this.spacing = charData.spacing;\n"
	"		this.blip = null;\n"
	"		this.hasPlayedBlip = false;\n"
	"	}\n"
	"\n"
	"	function DialogDrawingChar(drawingId, effectList, effectParameterList, BITSYBOX_HACK_renderer) {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)\n"
	"		this.effectParameterList = effectParameterList.slice();\n"
	"\n"
	"		// get the first frame of the drawing and flatten it\n"
	"		var drawingData = BITSYBOX_HACK_renderer ? BITSYBOX_HACK_renderer.GetDrawingSource(drawingId)[0] : renderer.GetDrawingSource(drawingId)[0];\n"
	"		var drawingDataFlat = [];\n"
	"		for (var i = 0; i < drawingData.length; i++) {\n"
	"			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);\n"
	"		}\n"
	"\n"
	"		this.bitmap = drawingDataFlat;\n"
	"		this.width = 8;\n"
	"		this.height = 8;\n"
	"		this.spacing = 8;\n"
	"	}\n"
	"\n"
	"	function DialogScriptControlChar() {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"	}\n"
	"\n"
	"	// is a control character really the best way to handle page breaks?\n"
	"	function DialogPageBreakChar() {\n"
	"		DialogChar.call(this);\n"
	"\n"
	"		this.width = 0;\n"
	"		this.height = 0;\n"
	"		this.spacing = 0;\n"
	"\n"
	"		this.isPageBreak = true;\n"
	"\n"
	"		var continueHandler = null;\n"
	"\n"
	"		this.SetContinueHandler = function(handler) {\n"
	"			continueHandler = handler;\n"
	"		};\n"
	"\n"
	"		this.OnContinue = function() {\n"
	"			if (continueHandler) {\n"
	"				continueHandler();\n"
	"			}\n"
	"		};\n"
	"	}\n"
	"\n"
	"	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {\n"
	"		// bitsy.log(\"add char array\");\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));\n"
	"		}\n"
	"		// bitsy.log(\"add char array end\");\n"
	"		return charArray;\n"
	"	}\n"
	"\n"
	"	function GetCharArrayWidth(charArray) {\n"
	"		var width = 0;\n"
	"		for(var i = 0; i < charArray.length; i++) {\n"
	"			width += charArray[i].spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	function GetStringWidth(str) {\n"
	"		var width = 0;\n"
	"		for (var i = 0; i < str.length; i++) {\n"
	"			var charData = font.getChar(str[i]);\n"
	"			width += charData.spacing;\n"
	"		}\n"
	"		return width;\n"
	"	}\n"
	"\n"
	"	var pixelsPerRow = 192; // hard-coded fun times!!!\n"
	"\n"
	"	this.AddScriptReturn = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var controlChar = new DialogScriptControlChar();\n"
	"		controlChar.SetPrintHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(controlChar);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddDrawing = function(drawingId, BITSYBOX_HACK_renderer) {\n"
	"		// bitsy.log(\"DRAWING ID \" + drawingId);\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters, BITSYBOX_HACK_renderer);\n"
	"\n"
	"		var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"		// TODO : clean up copy-pasted code here :/\n"
	"		if (afterManualPagebreak) {\n"
	"			this.FlipPage(); // hacky\n"
	"\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"\n"
	"			afterManualPagebreak = false;\n"
	"		}\n"
	"		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength < BITSYBOX_HACK_maxPageLines) {\n"
	"			//stay on same row\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else if (curRowIndex < BITSYBOX_HACK_maxPageLines) {\n"
	"			//start next row\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex++;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"		else {\n"
	"			//start next page\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"			curRowArr.push(drawingChar);\n"
	"		}\n"
	"\n"
	"		isActive = true; // this feels like a bad way to do this???\n"
	"	}\n"
	"\n"
	"	// TODO : convert this into something that takes DialogChar arrays\n"
	"	this.AddText = function(textStr) {\n"
	"		bitsy.log(\"ADD TEXT >>\" + textStr + \"<<\");\n"
	"\n"
	"		//process dialog so it's easier to display\n"
	"		var words = textStr.split(\" \");\n"
	"\n"
	"		// var curPageIndex = this.CurPageCount() - 1;\n"
	"		// var curRowIndex = this.CurRowCount() - 1;\n"
	"		// var curRowArr = this.CurRow();\n"
	"\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		for (var i = 0; i < words.length; i++) {\n"
	"			var word = words[i];\n"
	"			if (arabicHandler.ContainsArabicCharacters(word)) {\n"
	"				word = arabicHandler.ShapeArabicCharacters(word);\n"
	"			}\n"
	"\n"
	"			var wordWithPrecedingSpace = ((i == 0) ? \"\" : \" \") + word;\n"
	"			var wordLength = GetStringWidth(wordWithPrecedingSpace);\n"
	"\n"
	"			var rowLength = GetCharArrayWidth(curRowArr);\n"
	"\n"
	"			if (afterManualPagebreak) {\n"
	"				this.FlipPage();\n"
	"\n"
	"				// hacky copied bit for page breaks\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"\n"
	"				afterManualPagebreak = false;\n"
	"			}\n"
	"			else if (rowLength + wordLength <= pixelsPerRow || rowLength < BITSYBOX_HACK_maxPageLines) {\n"
	"				//stay on same row\n"
	"				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"			else if (curRowIndex < BITSYBOX_HACK_maxPageLines) {\n"
	"				//start next row\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex++;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"			else {\n"
	"				//start next page\n"
	"				buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"				buffer.push([]);\n"
	"				curPageIndex++;\n"
	"				buffer[curPageIndex].push([]);\n"
	"				curRowIndex = 0;\n"
	"				curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);\n"
	"			}\n"
	"		}\n"
	"\n"
	"		//destroy any empty stuff\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		var lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length == 0) {\n"
	"			lastPage.splice(lastPage.length-1, 1);\n"
	"		}\n"
	"		if (lastPage.length == 0) {\n"
	"			buffer.splice(buffer.length-1, 1);\n"
	"		}\n"
	"\n"
	"		//finish up \n"
	"		lastPage = buffer[buffer.length-1];\n"
	"		lastRow = lastPage[lastPage.length-1];\n"
	"		if (lastRow.length > 0) {\n"
	"			var lastChar = lastRow[lastRow.length-1];\n"
	"		}\n"
	"\n"
	"		// bitsy.log(buffer);\n"
	"\n"
	"		bitsy.log(\"add text finished\");\n"
	"\n"
	"		isActive = true;\n"
	"	};\n"
	"\n"
	"	this.AddLinebreak = function() {\n"
	"		var lastPage = buffer[buffer.length-1];\n"
	"		if (lastPage.length <= BITSYBOX_HACK_maxPageLines) {\n"
	"			// bitsy.log(\"LINEBREAK - NEW ROW \");\n"
	"			// add new row\n"
	"			lastPage.push([]);\n"
	"		}\n"
	"		else {\n"
	"			// add new page\n"
	"			buffer.push([[]]);\n"
	"		}\n"
	"		// bitsy.log(buffer);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.AddPagebreak = function(onReturnHandler) {\n"
	"		var curPageIndex = buffer.length - 1;\n"
	"		var curRowIndex = buffer[curPageIndex].length - 1;\n"
	"		var curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"		// need to actually create a whole new page if following another pagebreak character\n"
	"		if (afterManualPagebreak) {\n"
	"			this.FlipPage(); // hacky\n"
	"\n"
	"			buffer[curPageIndex][curRowIndex] = curRowArr;\n"
	"			buffer.push([]);\n"
	"			curPageIndex++;\n"
	"			buffer[curPageIndex].push([]);\n"
	"			curRowIndex = 0;\n"
	"			curRowArr = buffer[curPageIndex][curRowIndex];\n"
	"\n"
	"			afterManualPagebreak = false;\n"
	"		}\n"
	"\n"
	"		var pagebreakChar = new DialogPageBreakChar();\n"
	"		pagebreakChar.SetContinueHandler(onReturnHandler);\n"
	"\n"
	"		curRowArr.push(pagebreakChar);\n"
	"\n"
	"		isActive = true;\n"
	"	}\n"
	"\n"
	"	this.hasTextEffect = function(name) {\n"
	"		return activeTextEffects.indexOf(name) != -1;\n"
	"	};\n"
	"\n"
	"	this.pushTextEffect = function(name, parameters) {\n"
	"		activeTextEffects.push(name);\n"
	"		activeTextEffectParameters.push(parameters);\n"
	"	};\n"
	"\n"
	"	this.popTextEffect = function(name) {\n"
	"		var i = activeTextEffects.lastIndexOf(name);\n"
	"		activeTextEffects.splice(i, 1);\n"
	"		activeTextEffectParameters.splice(i, 1);\n"
	"	};\n"
	"\n"
	"	/* this is a hook for GIF rendering */\n"
	"	var didPageFinishThisFrame = false;\n"
	"	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };\n"
	"\n"
	"	var didFlipPageThisFrame = false;\n"
	"	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };\n"
	"\n"
	"	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky\n"
	"};\n"
	"\n"
	"/* ARABIC */\n"
	"var ArabicHandler = function() {\n"
	"\n"
	"	var arabicCharStart = 0x0621;\n"
	"	var arabicCharEnd = 0x064E;\n"
	"\n"
	"	var CharacterForm = {\n"
	"		Isolated : 0,\n"
	"		Final : 1,\n"
	"		Initial : 2,\n"
	"		Middle : 3\n"
	"	};\n"
	"\n"
	"	// map glyphs to their character forms\n"
	"	var glyphForms = {\n"
	"		/*		 Isolated, Final, Initial, Middle Forms	*/\n"
	"		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ \n"
	"		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ \n"
	"		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ \n"
	"		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ \n"
	"		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ \n"
	"		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ \n"
	"		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ \n"
	"		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ \n"
	"		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ \n"
	"		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ \n"
	"		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ \n"
	"		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ \n"
	"		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ \n"
	"		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ \n"
	"		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ \n"
	"		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ \n"
	"		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ \n"
	"		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ \n"
	"		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ \n"
	"		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ \n"
	"		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ \n"
	"		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ \n"
	"		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ \n"
	"		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ \n"
	"		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ \n"
	"		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ \n"
	"		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */\n"
	"		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ \n"
	"		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ \n"
	"		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ \n"
	"		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ \n"
	"		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ \n"
	"		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ \n"
	"		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ \n"
	"		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ \n"
	"		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ \n"
	"		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ \n"
	"		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ \n"
	"		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/\n"
	"		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/\n"
	"		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/\n"
	"		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */\n"
	"	};\n"
	"\n"
	"	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];\n"
	"\n"
	"	function IsArabicCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return (code >= arabicCharStart && code <= arabicCharEnd);\n"
	"	}\n"
	"\n"
	"	function ContainsArabicCharacters(word) {\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (IsArabicCharacter(word[i])) {\n"
	"				return true;\n"
	"			}\n"
	"		}\n"
	"		return false;\n"
	"	}\n"
	"\n"
	"	function IsDisconnectedCharacter(char) {\n"
	"		var code = char.charCodeAt(0);\n"
	"		return disconnectedCharacters.indexOf(code) != -1;\n"
	"	}\n"
	"\n"
	"	function ShapeArabicCharacters(word) {\n"
	"		var shapedWord = \"\";\n"
	"\n"
	"		for (var i = 0; i < word.length; i++) {\n"
	"			if (!IsArabicCharacter(word[i])) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);\n"
	"\n"
	"			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);\n"
	"\n"
	"			var form;\n"
	"			if (!connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Isolated;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && !connectedToNextChar) {\n"
	"				form = CharacterForm.Final;\n"
	"			}\n"
	"			else if (!connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Initial;\n"
	"			}\n"
	"			else if (connectedToPreviousChar && connectedToNextChar) {\n"
	"				form = CharacterForm.Middle;\n"
	"			}\n"
	"\n"
	"			var code = word[i].charCodeAt(0);\n"
	"\n"
	"			// handle lam alef special case\n"
	"			if (code == 0x0644 && connectedToNextChar) {\n"
	"				var nextCode = word[i+1].charCodeAt(0);\n"
	"				var specialCode = null;\n"
	"				if (nextCode == 0x0622) {\n"
	"					// alef madd\n"
	"					specialCode = glyphForms[0x064b][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0623) {\n"
	"					// hamza above\n"
	"					specialCode = glyphForms[0x064c][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0625) {\n"
	"					// hamza below\n"
	"					specialCode = glyphForms[0x064d][form];\n"
	"				}\n"
	"				else if (nextCode == 0x0627) {\n"
	"					// alef\n"
	"					specialCode = glyphForms[0x064e][form];\n"
	"				}\n"
	"\n"
	"				if (specialCode != null) {\n"
	"					shapedWord += String.fromCharCode(specialCode);\n"
	"					i++; // skip a step\n"
	"					continue;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			// hacky?\n"
	"			if (form === CharacterForm.Isolated) {\n"
	"				shapedWord += word[i];\n"
	"				continue;\n"
	"			}\n"
	"\n"
	"			var shapedCode = glyphForms[code][form];\n"
	"			shapedWord += String.fromCharCode(shapedCode);\n"
	"		}\n"
	"\n"
	"		return shapedWord;\n"
	"	}\n"
	"\n"
	"	this.ContainsArabicCharacters = ContainsArabicCharacters;\n"
	"	this.ShapeArabicCharacters = ShapeArabicCharacters;\n"
	"}\n"
	"\n"
	"/* TEXT EFFECTS */\n"
	"var TextEffects = {};\n"
	"\n"
	"function RainbowEffect() {\n"
	"	function positiveModulo(number, divisor) {\n"
	"		return ((number % divisor) + divisor) % divisor;\n"
	"	}\n"
	"\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"rbw\"] = new RainbowEffect();\n"
	"\n"
	"function ColorEffect(index) {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		if (parameters && parameters.length > 0) {\n"
	"			char.color = tileColorStartIndex + parameters[0];\n"
	"		}\n"
	"		else {\n"
	"			char.color = tileColorStartIndex + index;\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"clr\"] = new ColorEffect();\n"
	"TextEffects[\"clr1\"] = new ColorEffect(0);\n"
	"TextEffects[\"clr2\"] = new ColorEffect(1);\n"
	"TextEffects[\"clr3\"] = new ColorEffect(2);\n"
	"\n"
	"function WavyEffect() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"wvy\"] = new WavyEffect();\n"
	"\n"
	"function ShakyEffect() {\n"
	"	function disturb(func, time, offset, mult1, mult2) {\n"
	"		return func((time * mult1) - (offset * mult2));\n"
	"	}\n"
	"\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.offset.y += 1.5\n"
	"						* disturb(Math.sin, time, char.col, 0.1, 0.5)\n"
	"						* disturb(Math.cos, time, char.col, 0.3, 0.2)\n"
	"						* disturb(Math.sin, time, char.row, 2.0, 1.0);\n"
	"		char.offset.x += 1.5\n"
	"						* disturb(Math.cos, time, char.row, 0.1, 1.0)\n"
	"						* disturb(Math.sin, time, char.col, 3.0, 0.7)\n"
	"						* disturb(Math.cos, time, char.col, 0.2, 0.3);\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"shk\"] = new ShakyEffect();\n"
	"\n"
	"/*\n"
	"// TODO : maybe use this in a future update?\n"
	"function YakEffect() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		if (char.char != \" \") {\n"
	"			char.blip = parameters[0];\n"
	"		}\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"yak\"] = new YakEffect();\n"
	"*/\n"
	"\n"
	"var DebugHighlightEffect = function() {\n"
	"	this.doEffect = function(char, time, parameters) {\n"
	"		char.color = tileColorStartIndex;\n"
	"	};\n"
	"}\n"
	"\n"
	"TextEffects[\"_debug_highlight\"] = new DebugHighlightEffect();\n"
	"\n"
	"} // Dialog()\n";

char* tune_bitsy =
	"tune\n"
	"\n"
	"# BITSY VERSION 7.12\n"
	"# DEVELOPMENT BUILD -- BITSY-WORKSPACE--SOUND\n"
	"! ROOM_FORMAT 1\n"
	"! TEXT_MODE 0\n"
	"! DLG_COMPAT 1\n"
	"\n"
	"PAL 0\n"
	"NAME blueprint\n"
	"0,82,204\n"
	"128,159,255\n"
	"255,255,255\n"
	"\n"
	"ROOM 0\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
	"0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0\n"
	"0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
	"NAME example room\n"
	"PAL 0\n"
	"\n"
	"ROOM 1\n"
	"19,0,1b,1b,1b,1b,1b,1b,1b,1b,w,x,y,0,l,m\n"
	"1a,0,1b,1b,1b,1b,1b,1b,1b,1b,z,10,11,0,0,0\n"
	"b,b,u,d,b,b,d,b,u,b,b,e,e,t,b,b\n"
	"c,c,e,f,c,c,e,c,u,e,c,c,c,c,c,c\n"
	"b,b,u,d,b,b,d,b,u,b,b,b,b,b,e,b\n"
	"c,c,u,f,c,c,f,c,u,c,c,c,c,c,c,c\n"
	"b,b,u,d,b,1c,12,12,12,12,1d,b,b,b,b,b\n"
	"0,0,u,g,0,0,g,0,u,0,0,0,0,0,0,0\n"
	"0,0,u,g,0,0,g,0,u,0,0,0,0,0,0,0\n"
	"c,c,u,f,c,c,f,c,u,c,c,c,c,c,c,c\n"
	"h,i,j,k,v,0,0,0,1j,1k,1n,0,0,0,0,0\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,1h,0,0\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
	"l,n,o,p,q,r,s,13,14,15,16,17,18,1b,1b,1b\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
	"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n"
	"PAL 0\n"
	"\n"
	"TIL 10\n"
	"11111111\n"
	"11111111\n"
	"10001111\n"
	"11101111\n"
	"11101111\n"
	"11100001\n"
	"11111111\n"
	"11111111\n"
	"NAME sqr4b\n"
	"COL 2\n"
	"\n"
	"TIL 11\n"
	"11111111\n"
	"11111111\n"
	"10011111\n"
	"11011111\n"
	"11011111\n"
	"11000001\n"
	"11111111\n"
	"11111111\n"
	"NAME sqr8b\n"
	"COL 2\n"
	"\n"
	"TIL 12\n"
	"00000000\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"00000000\n"
	"NAME note3\n"
	"COL 2\n"
	"\n"
	"TIL 13\n"
	"00000000\n"
	"00000000\n"
	"00011000\n"
	"00111100\n"
	"01111110\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME hi\n"
	"COL 2\n"
	"\n"
	"TIL 14\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"01111110\n"
	"00111100\n"
	"00011000\n"
	"00000000\n"
	"00000000\n"
	"NAME lo\n"
	"COL 2\n"
	"\n"
	"TIL 15\n"
	"00000000\n"
	"01111110\n"
	"01100110\n"
	"01000010\n"
	"01000010\n"
	"01100110\n"
	"01111110\n"
	"00000000\n"
	"NAME plus\n"
	"COL 2\n"
	"\n"
	"TIL 16\n"
	"00000000\n"
	"01111110\n"
	"01111110\n"
	"01000010\n"
	"01000010\n"
	"01111110\n"
	"01111110\n"
	"00000000\n"
	"NAME minus\n"
	"COL 2\n"
	"\n"
	"TIL 17\n"
	"00000000\n"
	"01111110\n"
	"01111110\n"
	"01100110\n"
	"01000010\n"
	"01111110\n"
	"01111110\n"
	"00000000\n"
	"NAME up\n"
	"COL 2\n"
	"\n"
	"TIL 18\n"
	"00000000\n"
	"01111110\n"
	"01111110\n"
	"01000010\n"
	"01100110\n"
	"01111110\n"
	"01111110\n"
	"00000000\n"
	"NAME down\n"
	"COL 2\n"
	"\n"
	"TIL 19\n"
	"00001000\n"
	"00001100\n"
	"00011000\n"
	"00101000\n"
	"01011100\n"
	"01001010\n"
	"00111100\n"
	"00011000\n"
	"NAME melody\n"
	"\n"
	"TIL a\n"
	"11111111\n"
	"10000001\n"
	"10000001\n"
	"10011001\n"
	"10011001\n"
	"10000001\n"
	"10000001\n"
	"11111111\n"
	"NAME block\n"
	"\n"
	"TIL b\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00011000\n"
	"00011000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME dot\n"
	"\n"
	"TIL c\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00111100\n"
	"00111100\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME dotb\n"
	"\n"
	"TIL d\n"
	"00000000\n"
	"00000000\n"
	"10000000\n"
	"00011000\n"
	"00011000\n"
	"00000000\n"
	"10000000\n"
	"00000000\n"
	"NAME dot4\n"
	"\n"
	"TIL e\n"
	"00000000\n"
	"00111100\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"00111100\n"
	"00000000\n"
	"NAME note\n"
	"COL 2\n"
	"\n"
	"TIL f\n"
	"00000000\n"
	"00000000\n"
	"10000000\n"
	"00111100\n"
	"00111100\n"
	"00000000\n"
	"10000000\n"
	"00000000\n"
	"NAME dotb4\n"
	"\n"
	"TIL g\n"
	"00000000\n"
	"00000000\n"
	"10000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"10000000\n"
	"00000000\n"
	"NAME bar\n"
	"\n"
	"TIL h\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"01111110\n"
	"NAME oct2\n"
	"COL 2\n"
	"\n"
	"TIL i\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"01111110\n"
	"00000000\n"
	"00111100\n"
	"NAME oct3\n"
	"COL 2\n"
	"\n"
	"TIL j\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"01111110\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"NAME oct4\n"
	"COL 2\n"
	"\n"
	"TIL k\n"
	"00000000\n"
	"01111110\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"NAME oct5\n"
	"COL 2\n"
	"\n"
	"TIL l\n"
	"00000000\n"
	"00111100\n"
	"01000000\n"
	"01000000\n"
	"01000000\n"
	"01000000\n"
	"01000000\n"
	"00111100\n"
	"NAME note_c\n"
	"\n"
	"TIL m\n"
	"00000000\n"
	"01010000\n"
	"11111000\n"
	"01010000\n"
	"11111000\n"
	"01010000\n"
	"00000000\n"
	"00000000\n"
	"NAME sharp\n"
	"\n"
	"TIL n\n"
	"00000000\n"
	"01111000\n"
	"01000100\n"
	"01000100\n"
	"01000100\n"
	"01000100\n"
	"01000100\n"
	"01111000\n"
	"NAME note_d\n"
	"\n"
	"TIL o\n"
	"00000000\n"
	"01111100\n"
	"01000000\n"
	"01000000\n"
	"01111000\n"
	"01000000\n"
	"01000000\n"
	"01111100\n"
	"NAME note_e\n"
	"\n"
	"TIL p\n"
	"00000000\n"
	"01111100\n"
	"01000000\n"
	"01000000\n"
	"01111000\n"
	"01000000\n"
	"01000000\n"
	"01000000\n"
	"NAME note_f\n"
	"\n"
	"TIL q\n"
	"00000000\n"
	"00111100\n"
	"01000000\n"
	"01000000\n"
	"01011100\n"
	"01000100\n"
	"01000100\n"
	"00111100\n"
	"NAME note_g\n"
	"\n"
	"TIL r\n"
	"00000000\n"
	"00111000\n"
	"01000100\n"
	"01000100\n"
	"01111100\n"
	"01000100\n"
	"01000100\n"
	"01000100\n"
	"NAME note_a\n"
	"\n"
	"TIL s\n"
	"00000000\n"
	"01111000\n"
	"01000100\n"
	"01000100\n"
	"01111000\n"
	"01000100\n"
	"01000100\n"
	"01111000\n"
	"NAME note_b\n"
	"\n"
	"TIL t\n"
	"01111110\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"01111110\n"
	"NAME note2\n"
	"COL 2\n"
	"\n"
	"TIL u\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"NAME beat\n"
	"\n"
	"TIL v\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"00000000\n"
	"00111100\n"
	"NAME oct\n"
	"\n"
	"TIL w\n"
	"00000000\n"
	"01111110\n"
	"00000010\n"
	"01111010\n"
	"01111010\n"
	"01111000\n"
	"01111110\n"
	"00000000\n"
	"NAME sqr2\n"
	"\n"
	"TIL x\n"
	"00000000\n"
	"01111110\n"
	"00001110\n"
	"01101110\n"
	"01101110\n"
	"01100000\n"
	"01111110\n"
	"00000000\n"
	"NAME sqr4\n"
	"\n"
	"TIL y\n"
	"00000000\n"
	"01111110\n"
	"00011110\n"
	"01011110\n"
	"01011110\n"
	"01000000\n"
	"01111110\n"
	"00000000\n"
	"NAME sqr8\n"
	"\n"
	"TIL z\n"
	"11111111\n"
	"11111111\n"
	"10000011\n"
	"11111011\n"
	"11111011\n"
	"11111001\n"
	"11111111\n"
	"11111111\n"
	"NAME sqr2b\n"
	"COL 2\n"
	"\n"
	"TIL 1a\n"
	"00000000\n"
	"00111000\n"
	"01000101\n"
	"01000100\n"
	"00100101\n"
	"00000100\n"
	"00001000\n"
	"00010000\n"
	"NAME harmony\n"
	"\n"
	"TIL 1b\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"NAME border\n"
	"\n"
	"TIL 1c\n"
	"00000000\n"
	"00111111\n"
	"01111111\n"
	"01111111\n"
	"01111111\n"
	"01111111\n"
	"00111111\n"
	"00000000\n"
	"NAME note3_l\n"
	"COL 2\n"
	"\n"
	"TIL 1d\n"
	"00000000\n"
	"11111100\n"
	"11111110\n"
	"11111110\n"
	"11111110\n"
	"11111110\n"
	"11111100\n"
	"00000000\n"
	"NAME note3_r\n"
	"COL 2\n"
	"\n"
	"TIL 1e\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"NAME note4\n"
	"COL 2\n"
	"\n"
	"TIL 1f\n"
	"01111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"01111111\n"
	"NAME note4_l\n"
	"COL 2\n"
	"\n"
	"TIL 1g\n"
	"11111110\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111111\n"
	"11111110\n"
	"NAME note4_r\n"
	"COL 2\n"
	"\n"
	"TIL 1h\n"
	"00000000\n"
	"00000000\n"
	"00111100\n"
	"00111100\n"
	"00111100\n"
	"00111100\n"
	"00000000\n"
	"00000000\n"
	"NAME bar_empty\n"
	"\n"
	"TIL 1i\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME empty\n"
	"\n"
	"TIL ICON_10\n"
	"00011000\n"
	"11111111\n"
	"00000000\n"
	"01011010\n"
	"01011010\n"
	"01011010\n"
	"01011010\n"
	"01011010\n"
	"NAME icon_delete\n"
	"\n"
	"TIL ICON_11\n"
	"00111100\n"
	"01000010\n"
	"10011001\n"
	"10001001\n"
	"10011001\n"
	"01000010\n"
	"00111100\n"
	"00000000\n"
	"NAME icon_visibility\n"
	"\n"
	"TIL ICON_12\n"
	"00111011\n"
	"01100110\n"
	"11001101\n"
	"10011001\n"
	"10110011\n"
	"01100110\n"
	"11011100\n"
	"00000000\n"
	"NAME icon_visibility_off\n"
	"\n"
	"TIL ICON_13\n"
	"00111100\n"
	"01000010\n"
	"10000101\n"
	"10001001\n"
	"10010001\n"
	"10100001\n"
	"01000010\n"
	"00111100\n"
	"NAME icon_cancel\n"
	"\n"
	"TIL ICON_14\n"
	"00000000\n"
	"00111000\n"
	"01101100\n"
	"01000100\n"
	"00101000\n"
	"00111000\n"
	"00010000\n"
	"00000000\n"
	"NAME icon_set_exit_location\n"
	"\n"
	"TIL ICON_15\n"
	"00001100\n"
	"00010110\n"
	"00111011\n"
	"01111101\n"
	"10111110\n"
	"10011100\n"
	"11001000\n"
	"11110000\n"
	"NAME icon_edit\n"
	"\n"
	"TIL ICON_16\n"
	"00011111\n"
	"00100001\n"
	"11110001\n"
	"00100001\n"
	"01000101\n"
	"11110001\n"
	"01000001\n"
	"00011111\n"
	"NAME icon_exit_two_way\n"
	"\n"
	"TIL ICON_17\n"
	"00011111\n"
	"00100001\n"
	"11110001\n"
	"00100001\n"
	"00000101\n"
	"00100001\n"
	"00100001\n"
	"00111111\n"
	"NAME icon_exit_one_way\n"
	"\n"
	"TIL ICON_18\n"
	"00111111\n"
	"00100001\n"
	"00100001\n"
	"00000001\n"
	"01000101\n"
	"11110001\n"
	"01000001\n"
	"00011111\n"
	"NAME icon_exit_one_way_reverse\n"
	"\n"
	"TIL ICON_19\n"
	"11101111\n"
	"11101111\n"
	"00000000\n"
	"10111101\n"
	"10111101\n"
	"00000000\n"
	"11110111\n"
	"11110111\n"
	"NAME icon_wall_on\n"
	"\n"
	"TIL ICON_20\n"
	"00111100\n"
	"01110010\n"
	"11100001\n"
	"10100001\n"
	"11100001\n"
	"11100001\n"
	"01010010\n"
	"00111100\n"
	"NAME icon_key_minp\n"
	"\n"
	"TIL ICON_21\n"
	"00111100\n"
	"01111110\n"
	"11111011\n"
	"10110101\n"
	"11111011\n"
	"11111111\n"
	"01011110\n"
	"00111100\n"
	"NAME icon_key_mind\n"
	"\n"
	"TIL ICON_22\n"
	"00000010\n"
	"00100011\n"
	"00110010\n"
	"00100010\n"
	"00100110\n"
	"01100110\n"
	"01100000\n"
	"00000000\n"
	"NAME icon_tune\n"
	"\n"
	"TIL ICON_23\n"
	"00000000\n"
	"00111100\n"
	"01000010\n"
	"10000001\n"
	"10100001\n"
	"10010001\n"
	"11111111\n"
	"00000000\n"
	"NAME icon_tempo_slow\n"
	"\n"
	"TIL ICON_24\n"
	"00001000\n"
	"00001100\n"
	"00011000\n"
	"00101000\n"
	"01011100\n"
	"01001010\n"
	"00111100\n"
	"00011000\n"
	"NAME icon_melody\n"
	"\n"
	"TIL ICON_25\n"
	"00000000\n"
	"00111000\n"
	"01000101\n"
	"01000100\n"
	"00100101\n"
	"00000100\n"
	"00001000\n"
	"00010000\n"
	"NAME icon_harmony\n"
	"\n"
	"TIL ICON_26\n"
	"00000000\n"
	"01111110\n"
	"01000010\n"
	"01000010\n"
	"01000010\n"
	"01000010\n"
	"11000011\n"
	"00000000\n"
	"NAME icon_sqr_p2\n"
	"\n"
	"TIL ICON_27\n"
	"00000000\n"
	"01111000\n"
	"01001000\n"
	"01001000\n"
	"01001000\n"
	"01001000\n"
	"11001111\n"
	"00000000\n"
	"NAME icon_sqr_p4\n"
	"\n"
	"TIL ICON_28\n"
	"00000000\n"
	"00000000\n"
	"00000001\n"
	"10101011\n"
	"11111111\n"
	"10101011\n"
	"00111001\n"
	"00000000\n"
	"NAME icon_instrument_melody\n"
	"\n"
	"TIL ICON_29\n"
	"00000000\n"
	"00111100\n"
	"01000010\n"
	"10000001\n"
	"10010001\n"
	"10010001\n"
	"11111111\n"
	"00000000\n"
	"NAME icon_tempo_medium\n"
	"\n"
	"TIL ICON_30\n"
	"00000000\n"
	"11110100\n"
	"10000110\n"
	"10111111\n"
	"10111111\n"
	"10000110\n"
	"11110100\n"
	"00000000\n"
	"NAME icon_move_right\n"
	"\n"
	"TIL ICON_31\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"01111100\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_sub\n"
	"\n"
	"TIL ICON_32\n"
	"00000011\n"
	"00010111\n"
	"00001110\n"
	"00010100\n"
	"00101010\n"
	"01010000\n"
	"11100000\n"
	"11000000\n"
	"NAME icon_eyedropper\n"
	"\n"
	"TIL ICON_33\n"
	"11111100\n"
	"10101010\n"
	"10111001\n"
	"10000001\n"
	"10111101\n"
	"10111101\n"
	"10111101\n"
	"11111111\n"
	"NAME icon_save\n"
	"\n"
	"TIL ICON_a\n"
	"00000011\n"
	"00000101\n"
	"00001010\n"
	"00010100\n"
	"00101000\n"
	"01010000\n"
	"11100000\n"
	"11110101\n"
	"NAME icon_paint\n"
	"\n"
	"TIL ICON_b\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00111100\n"
	"01111110\n"
	"10111101\n"
	"00100100\n"
	"00100100\n"
	"NAME icon_avatar\n"
	"\n"
	"TIL ICON_c\n"
	"00000000\n"
	"01010001\n"
	"01110001\n"
	"01110010\n"
	"01111100\n"
	"00111100\n"
	"00100100\n"
	"00000000\n"
	"NAME icon_sprite\n"
	"\n"
	"TIL ICON_d\n"
	"11111111\n"
	"10000001\n"
	"10000001\n"
	"10011001\n"
	"10011001\n"
	"10000001\n"
	"10000001\n"
	"11111111\n"
	"NAME icon_tile\n"
	"\n"
	"TIL ICON_e\n"
	"00111100\n"
	"00100100\n"
	"00111100\n"
	"00010000\n"
	"00011000\n"
	"00010000\n"
	"00011000\n"
	"00000000\n"
	"NAME icon_item\n"
	"\n"
	"TIL ICON_f\n"
	"11000110\n"
	"11101110\n"
	"01111100\n"
	"00111000\n"
	"01111100\n"
	"11101110\n"
	"11000110\n"
	"00000000\n"
	"NAME icon_close\n"
	"\n"
	"TIL ICON_g\n"
	"00000111\n"
	"00000011\n"
	"00000101\n"
	"00001000\n"
	"01010000\n"
	"01100000\n"
	"01110000\n"
	"00000000\n"
	"NAME icon_expand_more\n"
	"\n"
	"TIL ICON_h\n"
	"00000001\n"
	"00001010\n"
	"00001100\n"
	"00001110\n"
	"01110000\n"
	"00110000\n"
	"01010000\n"
	"10000000\n"
	"NAME icon_expand_less\n"
	"\n"
	"TIL ICON_i\n"
	"00001000\n"
	"01101010\n"
	"00111110\n"
	"11100100\n"
	"00100111\n"
	"01111100\n"
	"01010110\n"
	"00010000\n"
	"NAME icon_settings\n"
	"\n"
	"TIL ICON_j\n"
	"00000000\n"
	"01100110\n"
	"10011001\n"
	"10000001\n"
	"01000010\n"
	"00100100\n"
	"00011000\n"
	"00000000\n"
	"NAME icon_about\n"
	"\n"
	"TIL ICON_k\n"
	"01111111\n"
	"01010101\n"
	"01111111\n"
	"01010101\n"
	"01111111\n"
	"01010101\n"
	"01111111\n"
	"00000000\n"
	"NAME icon_room\n"
	"\n"
	"TIL ICON_l\n"
	"00011111\n"
	"00100001\n"
	"11110001\n"
	"00100001\n"
	"00000101\n"
	"00100001\n"
	"00100001\n"
	"00111111\n"
	"NAME icon_exits_endings\n"
	"\n"
	"TIL ICON_m\n"
	"00011110\n"
	"00110011\n"
	"00100001\n"
	"00100001\n"
	"00110011\n"
	"01111110\n"
	"11100000\n"
	"11000000\n"
	"NAME icon_search\n"
	"\n"
	"TIL ICON_n\n"
	"00111110\n"
	"01110111\n"
	"11011101\n"
	"11111111\n"
	"10111110\n"
	"11110000\n"
	"01111000\n"
	"00111000\n"
	"NAME icon_colors\n"
	"\n"
	"TIL ICON_o\n"
	"01111110\n"
	"11000011\n"
	"10000001\n"
	"10000001\n"
	"11000001\n"
	"01111011\n"
	"00010110\n"
	"00011100\n"
	"NAME icon_dialog\n"
	"\n"
	"TIL ICON_p\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"01111110\n"
	"00111100\n"
	"00011000\n"
	"00000000\n"
	"01111110\n"
	"NAME icon_download\n"
	"\n"
	"TIL ICON_q\n"
	"00000000\n"
	"00111100\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"00111100\n"
	"00000000\n"
	"NAME icon_record\n"
	"\n"
	"TIL ICON_r\n"
	"11101010\n"
	"10101010\n"
	"11101010\n"
	"00000000\n"
	"10111010\n"
	"10101010\n"
	"10111010\n"
	"00000000\n"
	"NAME icon_game_data\n"
	"\n"
	"TIL ICON_s\n"
	"00011110\n"
	"00110010\n"
	"01110000\n"
	"01000010\n"
	"01000111\n"
	"01000010\n"
	"01000000\n"
	"01111110\n"
	"NAME icon_new_game\n"
	"\n"
	"TIL ICON_t\n"
	"00000000\n"
	"01101110\n"
	"01000110\n"
	"01001010\n"
	"01010000\n"
	"01000010\n"
	"01111110\n"
	"00000000\n"
	"NAME icon_open_tool\n"
	"\n"
	"TIL ICON_u\n"
	"00000000\n"
	"01100000\n"
	"01111000\n"
	"01111110\n"
	"01111000\n"
	"01100000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_play\n"
	"\n"
	"TIL ICON_v\n"
	"00000000\n"
	"01111100\n"
	"01111100\n"
	"01111100\n"
	"01111100\n"
	"01111100\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_stop\n"
	"\n"
	"TIL ICON_w\n"
	"00000000\n"
	"00001000\n"
	"00011000\n"
	"00111000\n"
	"00011000\n"
	"00001000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_previous\n"
	"\n"
	"TIL ICON_x\n"
	"00000000\n"
	"00010000\n"
	"00011000\n"
	"00011100\n"
	"00011000\n"
	"00010000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_next\n"
	"\n"
	"TIL ICON_y\n"
	"00000000\n"
	"00010000\n"
	"00010000\n"
	"01111100\n"
	"00010000\n"
	"00010000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_add\n"
	"\n"
	"TIL ICON_z\n"
	"01111000\n"
	"10001000\n"
	"10011110\n"
	"10100010\n"
	"10100010\n"
	"10100010\n"
	"11100010\n"
	"00111110\n"
	"NAME icon_copy\n"
	"\n"
	"TIL ICON_1a\n"
	"11011011\n"
	"10000001\n"
	"00000000\n"
	"10000001\n"
	"10000001\n"
	"00000000\n"
	"10000001\n"
	"11011011\n"
	"NAME icon_wall_off\n"
	"\n"
	"TIL ICON_1b\n"
	"00100100\n"
	"01000010\n"
	"01000010\n"
	"10000001\n"
	"01000010\n"
	"01000010\n"
	"00100100\n"
	"00000000\n"
	"NAME icon_code_edit\n"
	"\n"
	"TIL ICON_1c\n"
	"00011000\n"
	"00111100\n"
	"01111110\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00000000\n"
	"01111110\n"
	"NAME icon_upload\n"
	"\n"
	"TIL ICON_1d\n"
	"00000000\n"
	"00111100\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"01111110\n"
	"00111100\n"
	"00000000\n"
	">\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_record_on\n"
	"\n"
	"TIL ICON_1e\n"
	"00000000\n"
	"00000000\n"
	"00111100\n"
	"00111100\n"
	"00111100\n"
	"00111100\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_record_stop\n"
	"\n"
	"TIL ICON_1f\n"
	"00011100\n"
	"01000010\n"
	"00011001\n"
	"00111101\n"
	"10111100\n"
	"10011000\n"
	"01000010\n"
	"00111000\n"
	">\n"
	"00110000\n"
	"01000010\n"
	"10011000\n"
	"10111101\n"
	"10111101\n"
	"00011001\n"
	"01000010\n"
	"00001100\n"
	"NAME icon_record_processing\n"
	"\n"
	"TIL ICON_1g\n"
	"00111100\n"
	"11111111\n"
	"11100111\n"
	"11000011\n"
	"11000011\n"
	"11100111\n"
	"11111111\n"
	"00000000\n"
	"NAME icon_record_snapshot\n"
	"\n"
	"TIL ICON_1h\n"
	"11100111\n"
	"10000001\n"
	"10111101\n"
	"00111100\n"
	"00111100\n"
	"10111101\n"
	"10000001\n"
	"11100111\n"
	"NAME icon_pagesize_full\n"
	"\n"
	"TIL ICON_1i\n"
	"01000000\n"
	"11011110\n"
	"01000010\n"
	"01011010\n"
	"01011010\n"
	"01000000\n"
	"01111111\n"
	"00000010\n"
	"NAME icon_pagesize_fixed\n"
	"\n"
	"TIL ICON_1j\n"
	"00001110\n"
	"00010110\n"
	"00010110\n"
	"00100110\n"
	"00111110\n"
	"01000110\n"
	"01000110\n"
	"11000111\n"
	"NAME icon_text_edit\n"
	"\n"
	"TIL ICON_1k\n"
	"01000000\n"
	"10100000\n"
	"11100000\n"
	"10101100\n"
	"10101010\n"
	"00001100\n"
	"00001010\n"
	"00001100\n"
	"NAME icon_text_effects\n"
	"\n"
	"TIL ICON_1l\n"
	"00111110\n"
	"01111111\n"
	"01100011\n"
	"00000111\n"
	"00011110\n"
	"00011000\n"
	"00000000\n"
	"00011000\n"
	"NAME icon_help\n"
	"\n"
	"TIL ICON_1m\n"
	"00011110\n"
	"00111110\n"
	"01101010\n"
	"11110110\n"
	"01101010\n"
	"00111110\n"
	"00011110\n"
	"00000000\n"
	"NAME icon_backspace\n"
	"\n"
	"TIL ICON_1n\n"
	"00000011\n"
	"00000110\n"
	"00001100\n"
	"00001100\n"
	"10011000\n"
	"11011000\n"
	"01110000\n"
	"00110000\n"
	"NAME icon_checkmark\n"
	"\n"
	"TIL ICON_1o\n"
	"00011110\n"
	"00110010\n"
	"01110010\n"
	"01000010\n"
	"01000010\n"
	"01000010\n"
	"01000010\n"
	"01111110\n"
	"NAME icon_file\n"
	"\n"
	"TIL ICON_1p\n"
	"00001100\n"
	"00011000\n"
	"00011001\n"
	"00011111\n"
	"00111110\n"
	"01110000\n"
	"11100000\n"
	"11000000\n"
	"NAME icon_tool\n"
	"\n"
	"TIL ICON_1q\n"
	"00000000\n"
	"00000000\n"
	"00010000\n"
	"00111000\n"
	"01111100\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_arrow_up\n"
	"\n"
	"TIL ICON_1r\n"
	"00000000\n"
	"00000000\n"
	"01111100\n"
	"00111000\n"
	"00010000\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"NAME icon_arrow_down\n"
	"\n"
	"TIL ICON_1s\n"
	"00100001\n"
	"01110010\n"
	"00100100\n"
	"00000000\n"
	"01010000\n"
	"00100111\n"
	"01010000\n"
	"00000000\n"
	"NAME icon_expression_edit\n"
	"\n"
	"TIL ICON_1t\n"
	"01111000\n"
	"01000110\n"
	"01000001\n"
	"01000110\n"
	"01111000\n"
	"01000000\n"
	"01000000\n"
	"11100000\n"
	"NAME icon_ending\n"
	"\n"
	"TIL ICON_1u\n"
	"00000000\n"
	"11100111\n"
	"10000001\n"
	"00011000\n"
	"00011000\n"
	"10000001\n"
	"11100111\n"
	"00000000\n"
	"NAME icon_pagesize_landscape\n"
	"\n"
	"TIL ICON_1v\n"
	"00000001\n"
	"00000010\n"
	"00111110\n"
	"00111010\n"
	"00110010\n"
	"00100010\n"
	"01111110\n"
	"10000000\n"
	"NAME icon_transition_effect\n"
	"\n"
	"TIL ICON_1w\n"
	"01110110\n"
	"00110001\n"
	"01010001\n"
	"10000001\n"
	"10000001\n"
	"10001010\n"
	"10001100\n"
	"01101110\n"
	"NAME icon_loop\n"
	"\n"
	"TIL ICON_1x\n"
	"10001000\n"
	"10101010\n"
	"10001000\n"
	"10101010\n"
	"10001000\n"
	"10101010\n"
	"10001000\n"
	"00000000\n"
	"NAME icon_bar_count\n"
	"\n"
	"TIL ICON_1y\n"
	"00000000\n"
	"00000000\n"
	"00100100\n"
	"00000000\n"
	"10011001\n"
	"00111100\n"
	"00000000\n"
	"11111111\n"
	"NAME icon_key_majp\n"
	"\n"
	"TIL ICON_1z\n"
	"00001000\n"
	"01000010\n"
	"00011000\n"
	"10111100\n"
	"00111101\n"
	"00011000\n"
	"01000010\n"
	"00010000\n"
	"NAME icon_key_majd\n"
	"\n"
	"TIL ICON_2a\n"
	"00000000\n"
	"00111100\n"
	"01000010\n"
	"10000001\n"
	"10001001\n"
	"10010001\n"
	"11111111\n"
	"00000000\n"
	"NAME icon_tempo_fast\n"
	"\n"
	"TIL ICON_2b\n"
	"00000000\n"
	"00111100\n"
	"01000010\n"
	"10000001\n"
	"10000001\n"
	"10011001\n"
	"11111111\n"
	"00000000\n"
	"NAME icon_tempo_turbo\n"
	"\n"
	"TIL ICON_2c\n"
	"00001000\n"
	"00001100\n"
	"00001000\n"
	"00011000\n"
	"00001000\n"
	"00011000\n"
	"00001000\n"
	"00011000\n"
	"NAME icon_strum\n"
	"\n"
	"TIL ICON_2d\n"
	"00001000\n"
	"00001100\n"
	"00001000\n"
	"00011010\n"
	"01000011\n"
	"01100010\n"
	"01000110\n"
	"11000000\n"
	"NAME icon_counterpoint\n"
	"\n"
	"TIL ICON_2e\n"
	"00111100\n"
	"00011000\n"
	"00011000\n"
	"00111100\n"
	"00100100\n"
	"01111110\n"
	"01100110\n"
	"00111100\n"
	"NAME icon_harmony_style\n"
	"\n"
	"TIL ICON_2f\n"
	"00000100\n"
	"00010010\n"
	"01001010\n"
	"00101010\n"
	"00101010\n"
	"01001010\n"
	"00010010\n"
	"00000100\n"
	"NAME icon_blip\n"
	"\n"
	"TIL ICON_2g\n"
	"00001111\n"
	"00010000\n"
	"00100111\n"
	"01001000\n"
	"01010011\n"
	"00000100\n"
	"01110000\n"
	"11111100\n"
	"NAME icon_rainbow\n"
	"\n"
	"TIL ICON_2h\n"
	"01100000\n"
	"00010000\n"
	"00010000\n"
	"00010000\n"
	"00001000\n"
	"00001000\n"
	"00001000\n"
	"00000110\n"
	"NAME icon_pitch_slide\n"
	"\n"
	"TIL ICON_2i\n"
	"00000010\n"
	"11001111\n"
	"00010010\n"
	"00010000\n"
	"00010000\n"
	"00100010\n"
	"11001111\n"
	"00000010\n"
	"NAME icon_shuffle\n"
	"\n"
	"TIL ICON_2j\n"
	"00010000\n"
	"01000100\n"
	"00010000\n"
	"10111010\n"
	"00010000\n"
	"01000100\n"
	"00010000\n"
	"00000000\n"
	"NAME icon_effect\n"
	"\n"
	"TIL ICON_2k\n"
	"00000000\n"
	"01100110\n"
	"00000000\n"
	"01100110\n"
	"01100110\n"
	"01111110\n"
	"00111100\n"
	"00000000\n"
	"NAME icon_magnet\n"
	"\n"
	"TIL ICON_2l\n"
	"11111110\n"
	"01010100\n"
	"11111110\n"
	"01000100\n"
	"01000100\n"
	"11111110\n"
	"01010100\n"
	"11111110\n"
	"NAME icon_animation\n"
	"\n"
	"TIL ICON_2m\n"
	"00111100\n"
	"01111110\n"
	"00101110\n"
	"00100110\n"
	"00011100\n"
	"00111110\n"
	"01010101\n"
	"00010100\n"
	"NAME icon_ledoux\n"
	"\n"
	"TIL ICON_2n\n"
	"00000000\n"
	"00100000\n"
	"01100000\n"
	"11111110\n"
	"11111111\n"
	"01100011\n"
	"00100001\n"
	"00000000\n"
	"NAME icon_undo\n"
	"\n"
	"TIL ICON_2o\n"
	"00000000\n"
	"00000100\n"
	"00000110\n"
	"01111111\n"
	"11111111\n"
	"11000110\n"
	"10000100\n"
	"00000000\n"
	"NAME icon_redo\n"
	"\n"
	"TIL ICON_2p\n"
	"00001100\n"
	"00001110\n"
	"00001010\n"
	"00001000\n"
	"00111000\n"
	"01111000\n"
	"00110000\n"
	"00000000\n"
	"NAME icon_note\n"
	"\n"
	"TIL ICON_2q\n"
	"00000000\n"
	"11111111\n"
	"00000000\n"
	"00000000\n"
	"11111111\n"
	"00000000\n"
	"00000000\n"
	"11111111\n"
	"NAME icon_arp_off\n"
	"\n"
	"TIL ICON_2r\n"
	"00000001\n"
	"11111011\n"
	"00000000\n"
	"00001000\n"
	"11011011\n"
	"00000000\n"
	"01000000\n"
	"11011111\n"
	"NAME icon_arp_up\n"
	"\n"
	"TIL ICON_2s\n"
	"01000000\n"
	"11011111\n"
	"00000000\n"
	"00001000\n"
	"11011011\n"
	"00000000\n"
	"00000001\n"
	"11111011\n"
	"NAME icon_arp_dwn\n"
	"\n"
	"TIL ICON_2t\n"
	"00000000\n"
	"11111111\n"
	"00000000\n"
	"00000010\n"
	"11110110\n"
	"00000000\n"
	"00100000\n"
	"01101111\n"
	"NAME icon_arp_int5\n"
	"\n"
	"TIL ICON_2u\n"
	"00000010\n"
	"11110110\n"
	"00000000\n"
	"00000000\n"
	"11111111\n"
	"00000000\n"
	"00100000\n"
	"01101111\n"
	"NAME icon_arp_int8\n"
	"\n"
	"TIL ICON_2v\n"
	"11111100\n"
	"01111000\n"
	"01111000\n"
	"11111110\n"
	"01111011\n"
	"01111011\n"
	"01111011\n"
	"00111110\n"
	"NAME icon_instrument_harmony\n"
	"\n"
	"TIL ICON_2w\n"
	"00000000\n"
	"01110000\n"
	"01010000\n"
	"01010000\n"
	"01010000\n"
	"01010000\n"
	"11011111\n"
	"00000000\n"
	"NAME icon_sqr_p8\n"
	"\n"
	"TIL ICON_2x\n"
	"00000000\n"
	"11001100\n"
	"00110011\n"
	"00000000\n"
	"00000000\n"
	"11001100\n"
	"00110011\n"
	"00000000\n"
	"NAME icon_wave\n"
	"\n"
	"TIL ICON_2y\n"
	"01000100\n"
	"10001000\n"
	"01000100\n"
	"00100010\n"
	"01000100\n"
	"10001000\n"
	"01000100\n"
	"00000000\n"
	"NAME icon_shake\n"
	"\n"
	"TIL ICON_2z\n"
	"00000000\n"
	"00101111\n"
	"01100001\n"
	"11111101\n"
	"11111101\n"
	"01100001\n"
	"00101111\n"
	"00000000\n"
	"NAME icon_move_left\n"
	"\n"
	"SPR A\n"
	"00011000\n"
	"00011000\n"
	"00011000\n"
	"00111100\n"
	"01111110\n"
	"10111101\n"
	"00100100\n"
	"00100100\n"
	"POS 1 1,0\n"
	"\n"
	"SPR a\n"
	"00000000\n"
	"00000000\n"
	"01010001\n"
	"01110001\n"
	"01110010\n"
	"01111100\n"
	"00111100\n"
	"00100100\n"
	"DLG 0\n"
	"POS 0 8,12\n"
	"\n"
	"SPR b\n"
	"11100000\n"
	"10011000\n"
	"10000110\n"
	"10000001\n"
	"10000001\n"
	"10000110\n"
	"10011000\n"
	"11100000\n"
	"NAME cursor_arrow\n"
	"\n"
	"SPR c\n"
	"00000000\n"
	"01100000\n"
	"01111000\n"
	"01111110\n"
	"01111110\n"
	"01111000\n"
	"01100000\n"
	"00000000\n"
	"NAME cursor_click\n"
	"\n"
	"SPR d\n"
	"00000000\n"
	"00010000\n"
	"00100000\n"
	"01111111\n"
	"11111000\n"
	"11111000\n"
	"01111000\n"
	"00000000\n"
	"NAME cursor_hand\n"
	"\n"
	"ITM 0\n"
	"00000000\n"
	"00000000\n"
	"00000000\n"
	"00111100\n"
	"01100100\n"
	"00100100\n"
	"00011000\n"
	"00000000\n"
	"NAME tea\n"
	"DLG 1\n"
	"\n"
	"ITM 1\n"
	"00000000\n"
	"00111100\n"
	"00100100\n"
	"00111100\n"
	"00010000\n"
	"00011000\n"
	"00010000\n"
	"00011000\n"
	"NAME key\n"
	"DLG 2\n"
	"\n"
	"DLG 0\n"
	"I'm a cat\n"
	"NAME cat dialog\n"
	"\n"
	"DLG 1\n"
	"You found a nice warm cup of tea\n"
	"\n"
	"DLG 2\n"
	"A key! {wvy}What does it open?{wvy}\n"
	"NAME key dialog\n"
	"\n"
	"VAR a\n"
	"42\n"
	"\n"
	"TUNE 0\n"
	"0,0,2G,0,A,0,B,0,2C5,0,B,A,G,0,2G,0\n"
	"G3,0,D,0,G3,0,D,0,2A3,0,E,0,C,0,E,0\n"
	">\n"
	"2F#,0,G,0,A,0,F#,0,2E,0,F#,E,4D,0,0,0\n"
	"2D,0,E,0,F#,0,D,0,2C,0,2G3,0,2F#3,0,D2,0\n"
	">\n"
	"0,0,2G,0,A,0,B,0,2C5,0,B,A,G,0,G,0\n"
	"2G2,0,D,D5,G3,G,D,0,2C2,0,E,E5,C3,C,E5,0\n"
	">\n"
	"2D,0,C5,B,A,0,A,0,4A,0,0,0,F#,0,0,0\n"
	"A2,0,E3,0,C3,0,E3,0,D3,0,A3,0,D,0,0,0\n"
	">\n"
	"2E5,0,2G,0,2G5,0,2G,0,2F#5,0,2E5,0,2D5,0,2C5,0\n"
	"2C3,0,2E,0,2E5,0,2C,0,2A3,0,2C,0,2F#,0,2E,0\n"
	">\n"
	"3B,0,0,0,2E5,0,D5,0,4A,0,0,0,G,0,0,0\n"
	"2G3,0,B3,0,2D,0,D3,0,2C3,0,G3,0,D#,0,0,0\n"
	">\n"
	"0,0,2G,0,A,0,2B,0,C5,0,B,C5,A,0,G,0\n"
	"A2,0,A3,0,C,0,2D,0,D#,0,D,E,C,0,C3,0\n"
	">\n"
	"8B,0,0,0,0,0,0,0,A,0,2F#,0,E,0,D,0\n"
	"D3,0,A3,0,F#,0,D,0,C,0,2D3,0,C3,0,F#3,0\n"
	"NAME tuneful town\n"
	"TMP FST\n"
	"SQR P4 P2\n";

char* tune_js =
	"tool.id = \"tune\";\n"
	"\n"
	"// todo : how do I feel about these being functions? should I rename the property?\n"
	"tool.name = function() {\n"
	"	return localization.GetStringOrFallback(\"tune_tool\", \"tune\");\n"
	"};\n"
	"\n"
	"tool.icon = \"tune\";\n"
	"tool.size = \"m\";\n"
	"tool.data = \"TUNE\"; // todo : what's the right naming convention?\n"
	"tool.worldData = \"tune.bitsy\"; // todo : is \"world\" a confusing name?\n"
	"tool.insertBefore = \"findCheck\"; // todo : name of option?\n"
	"tool.aboutPage = \"./tools/tune\";\n"
	"\n"
	"// todo : do something to re-enable the live preview?\n"
	"// trying out giving each tool its own sound player\n"
	"tool.soundPlayer = new SoundPlayer();\n"
	"tool.soundPlayer.tag = \"tune_tool\"; // for debugging\n"
	"\n"
	"var Menu = {\n"
	"	TUNE: 0,\n"
	"	COMPOSE: 1,\n"
	"	INSTRUMENT: 2,\n"
	"	STYLE: 3,\n"
	"};\n"
	"var curMenu = Menu.TUNE;\n"
	"\n"
	"var NOTE_EDIT = {\n"
	"	NONE : -1,\n"
	"	ADD : 0,\n"
	"	REMOVE : 1,\n"
	"};\n"
	"\n"
	"var NOTE_TYPE = {\n"
	"	NOTE : 0,\n"
	"	BLIP : 1,\n"
	"};\n"
	"\n"
	"var curTuneId = \"0\";\n"
	"var curBarIndex = 0;\n"
	"var isMelody = true;\n"
	"\n"
	"var curEditMode = NOTE_EDIT.NONE;\n"
	"var curNoteMode = NOTE_TYPE.NOTE;\n"
	"\n"
	"var isMusicPlaying = false;\n"
	"var isBarLooping = false;\n"
	"\n"
	"var staffY = 14;\n"
	"var octaveY = 15;\n"
	"var addBarX = 9;\n"
	"var barSelectX = 0;\n"
	"\n"
	"var melodyBarTileIds = null;\n"
	"var harmonyBarTileIds = null;\n"
	"var blipTileIds = [];\n"
	"var blipInvertedTileIds = [];\n"
	"\n"
	"var octaveTileNames = [\"oct2\", \"oct3\", \"oct4\", \"oct5\"];\n"
	"var arpeggioPatternIcons = [\"arp_off\", \"arp_up\", \"arp_dwn\", \"arp_int5\", \"arp_int8\"];\n"
	"\n"
	"var noteEdit = {\n"
	"	startIndex: null,\n"
	"	endIndex: null,\n"
	"	curNoteId: null,\n"
	"};\n"
	"\n"
	"var prevPlayMode = false;\n"
	"var prevIsMouseDown = false;\n"
	"\n"
	"/* KEYS */\n"
	"var MusicalKey = {\n"
	"	UNKNOWN: 0,\n"
	"	MAJOR_PENTATONIC: 1,\n"
	"	MINOR_PENTATONIC: 2,\n"
	"	MAJOR_DIATONIC: 3,\n"
	"	MINOR_DIATONIC: 4,\n"
	"	CHROMATIC: 5\n"
	"};\n"
	"var keyNames = [\"unknown\", \"major\", \"minor\", \"full major\", \"full minor\", \"chromatic\"];\n"
	"var keyDescriptions = [\"please select a key\", \"C major pentatonic\", \"C minor pentatonic\", \"C major diatonic\", \"C minor diatonic\", \"full keyboard\"];\n"
	"\n"
	"// c major key notes\n"
	"var majorNotes = [Note.C, Note.D, Note.E, Note.F, Note.G, Note.A, Note.B];\n"
	"// c minor key notes\n"
	"var minorNotes = [Note.C, Note.D, Note.D_SHARP, Note.F, Note.G, Note.G_SHARP, Note.A_SHARP];\n"
	"\n"
	"// scales\n"
	"var pentatonicScale = [Solfa.D, Solfa.R, Solfa.M, Solfa.S, Solfa.L];\n"
	"var diatonicScale = [Solfa.D, Solfa.R, Solfa.M, Solfa.F, Solfa.S, Solfa.L, Solfa.T];\n"
	"\n"
	"var keys = [];\n"
	"keys[MusicalKey.MAJOR_PENTATONIC] = { notes: majorNotes, scale: pentatonicScale };\n"
	"keys[MusicalKey.MINOR_PENTATONIC] = { notes: minorNotes, scale: pentatonicScale };\n"
	"keys[MusicalKey.MAJOR_DIATONIC] = { notes: majorNotes, scale: diatonicScale };\n"
	"keys[MusicalKey.MINOR_DIATONIC] = { notes: minorNotes, scale: diatonicScale };\n"
	"\n"
	"var curKeyId = MusicalKey.UNKNOWN;\n"
	"\n"
	"function getKeyId(key) {\n"
	"	for (var k in MusicalKey) {\n"
	"		var id = MusicalKey[k];\n"
	"\n"
	"		// can't match unknown or chromatic\n"
	"		if (id === MusicalKey.UNKNOWN || id === MusicalKey.CHROMATIC) {\n"
	"			continue;\n"
	"		}\n"
	"\n"
	"		// check that both keys have the same number of scale degrees\n"
	"		if (key.scale.length != keys[id].scale.length) {\n"
	"			continue;\n"
	"		}\n"
	"\n"
	"		// check for exact match of notes & scale degrees\n"
	"		var isMatch = true;\n"
	"\n"
	"		for (var i = 0; i < key.notes.length; i++) {\n"
	"			if (key.notes[i] != keys[id].notes[i]) {\n"
	"				isMatch = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		for (var i = 0; i < key.scale.length; i++) {\n"
	"			if (key.scale[i] != keys[id].scale[i]) {\n"
	"				isMatch = false;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		if (isMatch) {\n"
	"			return id;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// if there are no matches, return unknown\n"
	"	return MusicalKey.UNKNOWN;\n"
	"}\n"
	"\n"
	"function getScaleNotes(key) {\n"
	"	var keyScale = [];\n"
	"	for (var note = Solfa.D; note < Solfa.COUNT; note++) {\n"
	"		if (key.scale.indexOf(note) > -1) {\n"
	"			keyScale.push(key.notes[note]);\n"
	"		}\n"
	"	}\n"
	"	return keyScale;\n"
	"}\n"
	"\n"
	"function convertToChromatic(tune) {\n"
	"	for (var i = 0; i < tune.melody.length; i++) {\n"
	"		for (var j = 0; j < barLength; j++) {\n"
	"			if (tune.melody[i][j].beats > 0) {\n"
	"				var scaleDegree = tune.melody[i][j].note;\n"
	"				tune.melody[i][j].note = tune.key.notes[scaleDegree];\n"
	"			}\n"
	"\n"
	"			if (tune.harmony[i][j].beats > 0) {\n"
	"				var scaleDegree = tune.harmony[i][j].note;\n"
	"				tune.harmony[i][j].note = tune.key.notes[scaleDegree];\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	tune.arpeggioPattern = ArpeggioPattern.OFF;\n"
	"	tune.key = null;\n"
	"}\n"
	"\n"
	"function copyKey(key) {\n"
	"	return {\n"
	"		notes: key.notes.slice(),\n"
	"		scale: key.scale.slice()\n"
	"	};\n"
	"}\n"
	"\n"
	"function convertToKey(tune, key) {\n"
	"	for (var i = 0; i < tune.melody.length; i++) {\n"
	"		for (var j = 0; j < barLength; j++) {\n"
	"			if (tune.melody[i][j].beats > 0) {\n"
	"				var scaleDegree = key.notes.indexOf(tune.melody[i][j].note);\n"
	"				if (scaleDegree != -1 && key.scale.indexOf(scaleDegree) != -1) {\n"
	"					tune.melody[i][j].note = scaleDegree;\n"
	"				}\n"
	"				else {\n"
	"					tune.melody[i][j].beats = 0;\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (tune.harmony[i][j].beats > 0) {\n"
	"				var scaleDegree = key.notes.indexOf(tune.harmony[i][j].note);\n"
	"				if (scaleDegree != -1 && key.scale.indexOf(scaleDegree) != -1) {\n"
	"					tune.harmony[i][j].note = scaleDegree;\n"
	"				}\n"
	"				else {\n"
	"					tune.harmony[i][j].beats = 0;\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	tune.key = copyKey(key);\n"
	"}\n"
	"\n"
	"function closestNoteInKey(noteId, key) {\n"
	"	// high note!\n"
	"	if (noteId >= Note.COUNT) {\n"
	"		return Note.COUNT;\n"
	"	}\n"
	"\n"
	"	if (key != null) {\n"
	"		var keyScale = getScaleNotes(key);\n"
	"		var closestNote = null;\n"
	"		for (var i = 0; i < keyScale.length; i++) {\n"
	"			var isClosest = (closestNote === null) ||\n"
	"				Math.abs(keyScale[i] - noteId) < Math.abs(keyScale[closestNote] - noteId);\n"
	"\n"
	"			if (isClosest) {\n"
	"				closestNote = i;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		return keyScale[closestNote];\n"
	"	}\n"
	"\n"
	"	return noteId;\n"
	"}\n"
	"\n"
	"function setNote(beatIndex, noteId, options) {\n"
	"	var bar = isMelody\n"
	"		? tune[curTuneId].melody[curBarIndex]\n"
	"		: tune[curTuneId].harmony[curBarIndex];\n"
	"	var key = tune[curTuneId].key;\n"
	"	var isSolfa = (key != null);\n"
	"\n"
	"	var beats = options.beats ? options.beats : 1;\n"
	"\n"
	"	eraseNotesInRange(beatIndex, beatIndex + beats - 1);\n"
	"\n"
	"	// test for high notes and keep note in range\n"
	"	var octaveOffset = (noteId >= Note.COUNT) ? 1 : 0;\n"
	"	noteId = (noteId % Note.COUNT);\n"
	"\n"
	"	// set octave\n"
	"	if (isMelody) {\n"
	"		bar[beatIndex].octave = Octave[4] + octaveOffset;\n"
	"	}\n"
	"	else {\n"
	"		bar[beatIndex].octave = Octave[2] + octaveOffset;\n"
	"	}\n"
	"\n"
	"	// update note\n"
	"	bar[beatIndex].beats = beats;\n"
	"	if (isSolfa) {\n"
	"		// solfa mode\n"
	"		var solfaNoteId = key.notes.indexOf(noteId);\n"
	"		if (solfaNoteId != -1 && key.scale.indexOf(solfaNoteId) != -1) {\n"
	"			bar[beatIndex].note = solfaNoteId;\n"
	"		}\n"
	"	}\n"
	"	else {\n"
	"		// chromatic mode\n"
	"		bar[beatIndex].note = noteId;\n"
	"	}\n"
	"\n"
	"	// update effect\n"
	"	if (options.noteMode && options.noteMode === NOTE_TYPE.BLIP) {\n"
	"		bar[beatIndex].blip = blipTool.getSelected();\n"
	"		blipTileIds[beatIndex] = undefined;\n"
	"		blipInvertedTileIds[beatIndex] = undefined;\n"
	"	}\n"
	"	else if (bar[beatIndex].blip != undefined) {\n"
	"		bar[beatIndex].blip = undefined;\n"
	"	}\n"
	"\n"
	"	if (!isMusicPlaying) { // HACK!\n"
	"		// play note\n"
	"		if (options.noteMode && options.noteMode === NOTE_TYPE.BLIP) {\n"
	"			tool.soundPlayer.playBlip(blip[blipTool.getSelected()], { pitch: bar[beatIndex] });\n"
	"		}\n"
	"		else {\n"
	"			tool.soundPlayer.playNote(\n"
	"				{ beats: 2, note: bar[beatIndex].note, octave: bar[beatIndex].octave, },\n"
	"				isMelody ? tune[curTuneId].instrumentA : tune[curTuneId].instrumentB,\n"
	"				bitsy.SOUND1,\n"
	"				key);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	refreshGameData();\n"
	"\n"
	"	redrawForeground = true;\n"
	"	redrawBarTiles = true;\n"
	"}\n"
	"\n"
	"function setArpeggioTonic(pitch) {\n"
	"	if (!tune[curTuneId] || isMelody) {\n"
	"		return NOTE_EDIT.NONE;\n"
	"	}\n"
	"\n"
	"	var bar = tune[curTuneId].harmony[curBarIndex];\n"
	"	var shouldClearArpeggio = !(bar[0].beats <= 0 || bar[0].note != pitch.note || bar[0].octave != pitch.octave);\n"
	"\n"
	"	// clear bar\n"
	"	for (var i = 0; i < barLength; i++) {\n"
	"		bar[i].beats = 0;\n"
	"	}\n"
	"\n"
	"	if (!shouldClearArpeggio) {\n"
	"		// set tonic\n"
	"		bar[0] = pitch;\n"
	"	}\n"
	"\n"
	"	if (!isMusicPlaying) {\n"
	"		tool.soundPlayer.playTune(\n"
	"			tune[curTuneId],\n"
	"			{ barIndex: curBarIndex, beatCount: 8, melody: false, });\n"
	"	}\n"
	"\n"
	"	refreshGameData();\n"
	"\n"
	"	redrawBarTiles = true;\n"
	"\n"
	"	// disable click and drag for arpeggios\n"
	"	return NOTE_EDIT.NONE;\n"
	"}\n"
	"\n"
	"// menu\n"
	"function menuUpdate() {\n"
	"	if (!tune[curTuneId]) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	// sub-menu select\n"
	"	tool.menu.push({ control: \"group\" });\n"
	"\n"
	"	tool.menu.push({\n"
	"		control: \"select\",\n"
	"		name: \"tuneMenu\",\n"
	"		value: curMenu,\n"
	"		options: [\n"
	"			{\n"
	"				icon: \"tune\",\n"
	"				text: localization.GetStringOrFallback(\"tune_tool\", \"tune\"),\n"
	"				description: \"tune editing tools\",\n"
	"				value: Menu.TUNE\n"
	"			},\n"
	"			{\n"
	"				icon: \"edit\",\n"
	"				text: localization.GetStringOrFallback(\"tune_compose\", \"compose\"),\n"
	"				description: \"note editing tools\",\n"
	"				value: Menu.COMPOSE\n"
	"			},\n"
	"			{\n"
	"				icon: \"instrument_melody\",\n"
	"				text: localization.GetStringOrFallback(\"tune_instrument\", \"instrument\"),\n"
	"				description: \"instrument settings\",\n"
	"				value: Menu.INSTRUMENT\n"
	"			},\n"
	"			{\n"
	"				icon: \"tune\",\n"
	"				text: localization.GetStringOrFallback(\"tune_style\", \"style\"),\n"
	"				description: \"tune settings\",\n"
	"				value: Menu.STYLE\n"
	"			},\n"
	"		],\n"
	"		onchange: function(e) {\n"
	"			curMenu = parseInt(e.target.value);\n"
	"		},\n"
	"	});\n"
	"\n"
	"	tool.menu.pop({ control: \"group\" });\n"
	"\n"
	"	/* SUB-MENUS */\n"
	"	if (curMenu === Menu.TUNE) {\n"
	"		// playback & tune length controls\n"
	"		tool.menu.push({ control: \"group\" });\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"toggle\",\n"
	"			icon: isMusicPlaying\n"
	"				? \"stop\"\n"
	"				: \"play\",\n"
	"			text: isMusicPlaying\n"
	"				? localization.GetStringOrFallback(\"stop_game\", \"stop\")\n"
	"				: localization.GetStringOrFallback(\"play_game\", \"play\"),\n"
	"			description: \"play tune from selected bar\",\n"
	"			id: \"tunePlayToggle\",\n"
	"			checked : isMusicPlaying,\n"
	"			onclick : function(e) {\n"
	"				isMusicPlaying = e.target.checked;\n"
	"				if (isMusicPlaying) {\n"
	"					tool.soundPlayer.playTune(tune[curTuneId], { barIndex: curBarIndex, loop: isBarLooping });\n"
	"				}\n"
	"				else {\n"
	"					tool.soundPlayer.stopTune();\n"
	"				}\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"toggle\",\n"
	"			icon : \"loop\",\n"
	"			text : \"loop\",\n"
	"			description : \"repeat current bar\",\n"
	"			id : \"tuneLoopToggle\", // hacky\n"
	"			checked : isBarLooping,\n"
	"			onclick : function(e) {\n"
	"				isBarLooping = e.target.checked;\n"
	"\n"
	"				if (isMusicPlaying) {\n"
	"					tool.soundPlayer.setLooping(isBarLooping);\n"
	"				}\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"label\",\n"
	"			icon: isMelody ? \"instrument_melody\" : \"instrument_harmony\",\n"
	"			text: localization.GetStringOrFallback(\"tune_bar\", \"bar\") + \" \" + (curBarIndex + 1) + \" / \" + tune[curTuneId].melody.length,\n"
	"			description: \"selected bar: \" + (curBarIndex + 1) + \" (\" + (isMelody ? \"melody\" : \"harmony\") + \")\"\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"move_left\",\n"
	"			text: \"move bar left\",\n"
	"			description: \"move selected bar left\",\n"
	"			enabled: curBarIndex > 0,\n"
	"			onclick: function() {\n"
	"				// swap this bar with the one to the left\n"
	"				if (curBarIndex <= 0) {\n"
	"					return;\n"
	"				}\n"
	"\n"
	"				var melodyTmp = tune[curTuneId].melody[curBarIndex];\n"
	"				var harmonyTmp = tune[curTuneId].harmony[curBarIndex];\n"
	"\n"
	"				tune[curTuneId].melody[curBarIndex] = tune[curTuneId].melody[curBarIndex - 1];\n"
	"				tune[curTuneId].harmony[curBarIndex] = tune[curTuneId].harmony[curBarIndex - 1];\n"
	"\n"
	"				curBarIndex--;\n"
	"				tune[curTuneId].melody[curBarIndex] = melodyTmp;\n"
	"				tune[curTuneId].harmony[curBarIndex] = harmonyTmp;\n"
	"\n"
	"				refreshGameData();\n"
	"				redrawBarTiles = true;\n"
	"				redrawBackground = true;\n"
	"				redrawForeground = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"move_right\",\n"
	"			text: \"move bar right\",\n"
	"			description: \"move selected bar right\",\n"
	"			enabled: curBarIndex < (tune[curTuneId].melody.length - 1),\n"
	"			onclick: function() {\n"
	"				// swap this bar with the one to the right\n"
	"				if (curBarIndex >= (tune[curTuneId].melody.length - 1)) {\n"
	"					return;\n"
	"				}\n"
	"\n"
	"				var melodyTmp = tune[curTuneId].melody[curBarIndex];\n"
	"				var harmonyTmp = tune[curTuneId].harmony[curBarIndex];\n"
	"\n"
	"				tune[curTuneId].melody[curBarIndex] = tune[curTuneId].melody[curBarIndex + 1];\n"
	"				tune[curTuneId].harmony[curBarIndex] = tune[curTuneId].harmony[curBarIndex + 1];\n"
	"\n"
	"				curBarIndex++;\n"
	"				tune[curTuneId].melody[curBarIndex] = melodyTmp;\n"
	"				tune[curTuneId].harmony[curBarIndex] = harmonyTmp;\n"
	"\n"
	"				refreshGameData();\n"
	"				redrawBarTiles = true;\n"
	"				redrawBackground = true;\n"
	"				redrawForeground = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"add\",\n"
	"			text: \"add new bar\",\n"
	"			description: \"add empty bar to end of tune\",\n"
	"			enabled: (tune[curTuneId].melody.length < maxTuneLength),\n"
	"			onclick: function() {\n"
	"				// add new bar\n"
	"				if (tune[curTuneId].melody.length >= maxTuneLength) {\n"
	"					return;\n"
	"				}\n"
	"\n"
	"				tune[curTuneId].melody.push(createTuneBarData());\n"
	"				tune[curTuneId].harmony.push(createTuneBarData());\n"
	"				curBarIndex = (tune[curTuneId].melody.length - 1);\n"
	"\n"
	"				refreshGameData();\n"
	"				redrawBarTiles = true;\n"
	"				redrawBackground = true;\n"
	"				redrawForeground = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"copy\",\n"
	"			text: \"copy bar\",\n"
	"			description: \"make copy of selected bar and add it to the to end of tune\",\n"
	"			enabled: (tune[curTuneId].melody.length < maxTuneLength),\n"
	"			onclick: function() {\n"
	"				// copy current bar\n"
	"				if (tune[curTuneId].melody.length >= maxTuneLength) {\n"
	"					return;\n"
	"				}\n"
	"\n"
	"				tune[curTuneId].melody.push(createTuneBarData());\n"
	"				tune[curTuneId].harmony.push(createTuneBarData());\n"
	"\n"
	"				var nextBarIndex = (tune[curTuneId].melody.length - 1);\n"
	"				copyBar(curBarIndex, nextBarIndex);\n"
	"\n"
	"				curBarIndex = nextBarIndex;\n"
	"\n"
	"				refreshGameData();\n"
	"				redrawBarTiles = true;\n"
	"				redrawBackground = true;\n"
	"				redrawForeground = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"delete\", // todo : better icon?\n"
	"			text: \"delete bar\",\n"
	"			description: \"remove selected bar from tune\",\n"
	"			onclick: function() {\n"
	"				// remove current bar\n"
	"				tune[curTuneId].melody.splice(curBarIndex, 1);\n"
	"				tune[curTuneId].harmony.splice(curBarIndex, 1);\n"
	"\n"
	"				if (tune[curTuneId].melody.length <= 0) {\n"
	"					tune[curTuneId].melody.push(createTuneBarData());\n"
	"					tune[curTuneId].harmony.push(createTuneBarData());\n"
	"				}\n"
	"\n"
	"				if (curBarIndex >= tune[curTuneId].melody.length) {\n"
	"					curBarIndex = tune[curTuneId].melody.length - 1;\n"
	"				}\n"
	"\n"
	"				refreshGameData();\n"
	"				redrawBarTiles = true;\n"
	"				redrawBackground = true;\n"
	"				redrawForeground = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"button\",\n"
	"			icon: \"close\",\n"
	"			text: \"quit (return to bitsybox)\",\n"
	"			onclick: function() {\n"
	"				__bitsybox_should_quit_tool_demo__ = true;\n"
	"			}\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"	}\n"
	"	else if (curMenu === Menu.COMPOSE) {\n"
	"		/* COMPOSITION TOOLS MENU */\n"
	"		// note entry mode\n"
	"		tool.menu.push({ control: \"group\" });\n"
	"\n"
	"		// tool.menu.push({\n"
	"		// 	control: \"label\",\n"
	"		// 	icon : \"edit\",\n"
	"		// 	description : \"note entry tool\",\n"
	"		// });\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"select\",\n"
	"			name: \"tuneNoteEntry\",\n"
	"			icon : \"edit\",\n"
	"			description : \"note entry tool\",\n"
	"			value: curNoteMode,\n"
	"			options: [\n"
	"				{\n"
	"					icon: \"note\",\n"
	"					text: localization.GetStringOrFallback(\"tune_note\", \"note\"),\n"
	"					description : \"click & drag to draw notes\",\n"
	"					value: NOTE_TYPE.NOTE,\n"
	"				},\n"
	"				// {\n"
	"				// 	icon: \"blip\",\n"
	"				// 	text: localization.GetStringOrFallback(\"blip_sfx\", \"blip\"),\n"
	"				// 	description : \"click to insert selected blip as a note\",\n"
	"				// 	value: NOTE_TYPE.BLIP,\n"
	"				// },\n"
	"			],\n"
	"			onchange: function(e) {\n"
	"				curNoteMode = parseInt(e.target.value);\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"\n"
	"		if (curKeyId != MusicalKey.UNKNOWN && curKeyId != MusicalKey.CHROMATIC) {\n"
	"			// strum settings\n"
	"			tool.menu.push({ control: \"group\", enabled: !isMelody });\n"
	"\n"
	"			// tool.menu.push({\n"
	"			// 	control: \"label\",\n"
	"			// 	icon: arpeggioPatternIcons[tune[curTuneId].arpeggioPattern],\n"
	"			// 	description: \"harmony strum pattern (arpeggios)\"\n"
	"			// });\n"
	"\n"
	"			tool.menu.push({\n"
	"				control: \"select\",\n"
	"				name: \"arpModeSelect\",\n"
	"				icon: arpeggioPatternIcons[tune[curTuneId].arpeggioPattern],\n"
	"				description: \"harmony strum pattern (arpeggios)\",\n"
	"				value: tune[curTuneId].arpeggioPattern,\n"
	"				options: [\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_arp_off\", \"strum off\"),\n"
	"						value: ArpeggioPattern.OFF,\n"
	"					},\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_arp_up\", \"strum chord (up)\"),\n"
	"						value: ArpeggioPattern.UP,\n"
	"					},\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_arp_down\", \"strum chord (down)\"),\n"
	"						value: ArpeggioPattern.DWN,\n"
	"					},\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_arp_int5\", \"strum interval (small)\"),\n"
	"						value: ArpeggioPattern.INT5,\n"
	"					},\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_arp_int8\", \"strum interval (big)\"),\n"
	"						value: ArpeggioPattern.INT8\n"
	"					}\n"
	"				],\n"
	"				onchange: function(e) {\n"
	"					tune[curTuneId].arpeggioPattern = parseInt(e.target.value);\n"
	"\n"
	"					refreshGameData();\n"
	"					redrawBarTiles = true;\n"
	"					redrawBackground = true;\n"
	"					redrawForeground = true;\n"
	"\n"
	"					if (!isMusicPlaying && tune[curTuneId].arpeggioPattern != ArpeggioPattern.OFF) {\n"
	"						tool.soundPlayer.playTune(\n"
	"							tune[curTuneId],\n"
	"							{ barIndex: curBarIndex, beatCount: 8, melody: false, });\n"
	"					}\n"
	"				}\n"
	"			});\n"
	"\n"
	"			tool.menu.pop({ control: \"group\" });\n"
	"		}\n"
	"	}\n"
	"	else if (curMenu === Menu.INSTRUMENT) {\n"
	"		/* INSTRUMENT MENU */\n"
	"		// melody instrument\n"
	"		tool.menu.push({ control: \"group\", enabled: isMelody });\n"
	"\n"
	"		// tool.menu.push({\n"
	"		// 	control: \"label\",\n"
	"		// 	icon: \"instrument_melody\",\n"
	"		// 	description: \"melody instrument tone\"\n"
	"		// });\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"select\",\n"
	"			name: \"tuneMelodyInstrument\",\n"
	"			icon: \"instrument_melody\",\n"
	"			description: \"melody instrument tone\",\n"
	"			value: tune[curTuneId].instrumentA,\n"
	"			options: [\n"
	"				{\n"
	"					icon: \"sqr_p2\",\n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse2\", \"tone P2\"),\n"
	"					description: \"tone A (square wave - duty 1/2)\",\n"
	"					value: SquareWave.P2,\n"
	"				},\n"
	"				{ \n"
	"					icon: \"sqr_p4\", \n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse4\", \"tone P4\"), \n"
	"					description: \"tone B (pulse wave - duty 1/4)\", \n"
	"					value: SquareWave.P4,\n"
	"				},\n"
	"				{\n"
	"					icon: \"sqr_p8\",\n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse8\", \"tone P8\"),\n"
	"					description: \"tone C (pulse wave - duty 1/8)\",\n"
	"					value: SquareWave.P8,\n"
	"				},\n"
	"			],\n"
	"			onchange: function(e) {\n"
	"				var pulse = parseInt(e.target.value);\n"
	"				tune[curTuneId].instrumentA = pulse;\n"
	"				if (!isMusicPlaying) { // HACK!\n"
	"					tool.soundPlayer.playNote(\n"
	"						{ beats: 1, note: Note.C, octave: Octave[4] },\n"
	"						pulse,\n"
	"						bitsy.SOUND2,\n"
	"						tune[curTuneId].key);\n"
	"				}\n"
	"				refreshGameData();\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"\n"
	"		// harmony instrument\n"
	"		tool.menu.push({ control: \"group\", enabled: !isMelody });\n"
	"\n"
	"		// tool.menu.push({\n"
	"		// 	control: \"label\",\n"
	"		// 	icon: \"instrument_harmony\",\n"
	"		// 	description: \"harmony instrument tone\"\n"
	"		// });\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"select\",\n"
	"			name: \"tuneHarmonyInstrument\",\n"
	"			icon: \"instrument_harmony\",\n"
	"			description: \"harmony instrument tone\",\n"
	"			value: tune[curTuneId].instrumentB,\n"
	"			options: [\n"
	"				{\n"
	"					icon: \"sqr_p2\",\n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse2\", \"tone P2\"),\n"
	"					description: \"tone A (square wave - duty 1/2)\",\n"
	"					value: SquareWave.P2,\n"
	"				},\n"
	"				{ \n"
	"					icon: \"sqr_p4\", \n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse4\", \"tone P4\"), \n"
	"					description: \"tone B (pulse wave - duty 1/4)\", \n"
	"					value: SquareWave.P4,\n"
	"				},\n"
	"				{\n"
	"					icon: \"sqr_p8\",\n"
	"					text: localization.GetStringOrFallback(\"tune_wave_pulse8\", \"tone P8\"),\n"
	"					description: \"tone C (pulse wave - duty 1/8)\",\n"
	"					value: SquareWave.P8,\n"
	"				},\n"
	"			],\n"
	"			onchange: function(e) {\n"
	"				var pulse = parseInt(e.target.value);\n"
	"				tune[curTuneId].instrumentB = pulse;\n"
	"				if (!isMusicPlaying) { // HACK!\n"
	"					tool.soundPlayer.playNote(\n"
	"						{ beats: 1, note: Note.C, octave: Octave[2] },\n"
	"						pulse,\n"
	"						bitsy.SOUND2,\n"
	"						tune[curTuneId].key);\n"
	"				}\n"
	"				refreshGameData();\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"	}\n"
	"	else if (curMenu === Menu.STYLE) {\n"
	"		/* STYLE MENU */\n"
	"		// tempo controls\n"
	"		tool.menu.push({ control: \"group\" });\n"
	"\n"
	"		var tempoIcon;\n"
	"		switch (tune[curTuneId].tempo) {\n"
	"			case Tempo.SLW:\n"
	"				tempoIcon = \"tempo_slow\";\n"
	"				break;\n"
	"			case Tempo.MED:\n"
	"				tempoIcon = \"tempo_medium\";\n"
	"				break;\n"
	"			case Tempo.FST:\n"
	"				tempoIcon = \"tempo_fast\";\n"
	"				break;\n"
	"			case Tempo.XFST:\n"
	"				tempoIcon = \"tempo_turbo\";\n"
	"				break;\n"
	"		}\n"
	"\n"
	"		// tool.menu.push({\n"
	"		// 	control: \"label\",\n"
	"		// 	icon: tempoIcon,\n"
	"		// 	text: localization.GetStringOrFallback(\"general_speed\", \"speed\"),\n"
	"		// 	description: \"tune speed (tempo)\"\n"
	"		// });\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"select\",\n"
	"			name: \"tuneTempo\",\n"
	"			icon: tempoIcon,\n"
	"			text: localization.GetStringOrFallback(\"general_speed\", \"speed\"),\n"
	"			description: \"tune speed (tempo)\",\n"
	"			value: tune[curTuneId].tempo,\n"
	"			options: [\n"
	"				{\n"
	"					text: localization.GetStringOrFallback(\"tune_tempo_slow\", \"slow\"),\n"
	"					description: \"60bpm (adagio)\",\n"
	"					value: Tempo.SLW,\n"
	"				},\n"
	"				{\n"
	"					text: localization.GetStringOrFallback(\"tune_tempo_med\", \"medium\"),\n"
	"					description: \"80bpm (andante)\",\n"
	"					value: Tempo.MED,\n"
	"				},\n"
	"				{\n"
	"					text: localization.GetStringOrFallback(\"tune_tempo_fast\", \"fast\"),\n"
	"					description: \"120bpm (moderato)\",\n"
	"					value: Tempo.FST,\n"
	"				},\n"
	"				{\n"
	"					text: localization.GetStringOrFallback(\"tune_tempo_xfast\", \"turbo\"),\n"
	"					description: \"160bpm (allegro)\",\n"
	"					value: Tempo.XFST,\n"
	"				},\n"
	"			],\n"
	"			onchange: function(e) {\n"
	"				tune[curTuneId].tempo = parseInt(e.target.value);\n"
	"				if (isMusicPlaying) {\n"
	"					tool.soundPlayer.setTempo(tune[curTuneId].tempo);\n"
	"				}\n"
	"				refreshGameData();\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"\n"
	"		// key transposition control\n"
	"		if (curKeyId != MusicalKey.UNKNOWN && curKeyId != MusicalKey.CHROMATIC) {\n"
	"			tool.menu.push({ control: \"group\" });\n"
	"\n"
	"			var isMajorKey = (curKeyId === MusicalKey.MAJOR_PENTATONIC)\n"
	"				|| (curKeyId === MusicalKey.MAJOR_DIATONIC);\n"
	"\n"
	"			// tool.menu.push({\n"
	"			// 	control: \"label\",\n"
	"			// 	icon: isMajorKey ? \"key_majp\" : \"key_minp\",\n"
	"			// 	text: localization.GetStringOrFallback(\"tune_key_basic\", \"mood\"),\n"
	"			// 	description: \"tune mood (transpose between major & minor key)\"\n"
	"			// });\n"
	"\n"
	"			tool.menu.push({\n"
	"				control: \"select\",\n"
	"				name: \"tuneKeyTranspose\",\n"
	"				icon: isMajorKey ? \"key_majp\" : \"key_minp\",\n"
	"				text: localization.GetStringOrFallback(\"tune_key_basic\", \"mood\"),\n"
	"				description: \"tune mood (transpose between major & minor key)\",\n"
	"				value: isMajorKey,\n"
	"				options: [\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_key_major\", \"cheery\"),\n"
	"						description: \"major key\",\n"
	"						value: true\n"
	"					},\n"
	"					{\n"
	"						text: localization.GetStringOrFallback(\"tune_key_minor\", \"gloomy\"),\n"
	"						description: \"minor key\",\n"
	"						value: false\n"
	"					},\n"
	"				],\n"
	"				onchange: function(e) {\n"
	"					// HACK!\n"
	"					if (e.target.value) {\n"
	"						// transpose to major key\n"
	"						tune[curTuneId].key.notes = majorNotes.slice();\n"
	"					}\n"
	"					else {\n"
	"						// transpose to minor key\n"
	"						tune[curTuneId].key.notes = minorNotes.slice();\n"
	"					}\n"
	"\n"
	"					// update key id\n"
	"					curKeyId = getKeyId(tune[curTuneId].key);\n"
	"\n"
	"					refreshGameData();\n"
	"					redrawBackground = true;\n"
	"					redrawForeground = true;\n"
	"				}\n"
	"			});\n"
	"\n"
	"			tool.menu.pop({ control: \"group\" });\n"
	"		}\n"
	"\n"
	"		// key controls\n"
	"		tool.menu.push({ control: \"group\" });\n"
	"\n"
	"		// tool.menu.push({\n"
	"		// 	control: \"label\",\n"
	"		// 	icon: \"settings\",\n"
	"		// 	text: localization.GetStringOrFallback(\"tune_key\", \"key\"),\n"
	"		// 	description: \"key: \" + keyNames[curKeyId] + \" (\" + keyDescriptions[curKeyId] + \")\"\n"
	"		// });\n"
	"\n"
	"		function makeKeyOption(key) {\n"
	"			var option = { text : keyNames[key], description : keyDescriptions[key], value : key, };\n"
	"\n"
	"			switch (key) {\n"
	"				case MusicalKey.MAJOR_PENTATONIC:\n"
	"				case MusicalKey.MINOR_PENTATONIC:\n"
	"					option.description += \" (basic)\";\n"
	"					break;\n"
	"				case MusicalKey.MAJOR_DIATONIC:\n"
	"				case MusicalKey.MINOR_DIATONIC:\n"
	"					option.description += \" (intermediate)\";\n"
	"					break;\n"
	"				case MusicalKey.CHROMATIC:\n"
	"					option.description += \" (advanced)\";\n"
	"					break;\n"
	"			}\n"
	"\n"
	"			return option;\n"
	"		}\n"
	"\n"
	"		tool.menu.push({\n"
	"			control: \"select\",\n"
	"			name: \"tuneKey\",\n"
	"			icon: \"settings\",\n"
	"			text: localization.GetStringOrFallback(\"tune_key\", \"key\"),\n"
	"			description: \"key: \" + keyNames[curKeyId] + \" (\" + keyDescriptions[curKeyId] + \")\",\n"
	"			value: curKeyId,\n"
	"			options: [\n"
	"				makeKeyOption(MusicalKey.UNKNOWN),\n"
	"				makeKeyOption(MusicalKey.MAJOR_PENTATONIC),\n"
	"				makeKeyOption(MusicalKey.MINOR_PENTATONIC),\n"
	"				makeKeyOption(MusicalKey.MAJOR_DIATONIC),\n"
	"				makeKeyOption(MusicalKey.MINOR_DIATONIC),\n"
	"				makeKeyOption(MusicalKey.CHROMATIC),\n"
	"			],\n"
	"			onchange: function(e) {\n"
	"				var nextKeyId = parseInt(e.target.value);\n"
	"				// HACK!\n"
	"				if (nextKeyId === MusicalKey.UNKNOWN) {\n"
	"					nextKeyId = (curKeyId >= MusicalKey.CHROMATIC) ? MusicalKey.MAJOR_PENTATONIC : MusicalKey.CHROMATIC;\n"
	"				}\n"
	"\n"
	"				if (nextKeyId != MusicalKey.UNKNOWN && curKeyId != nextKeyId) {\n"
	"					if (nextKeyId === MusicalKey.CHROMATIC) {\n"
	"						// convert from a key to chromatic\n"
	"						convertToChromatic(tune[curTuneId]);\n"
	"					}\n"
	"					else if (curKeyId === MusicalKey.CHROMATIC) {\n"
	"						// convert from chromatic scale to a key\n"
	"						convertToKey(tune[curTuneId], keys[nextKeyId]);\n"
	"					}\n"
	"					else {\n"
	"						// when converting from key to key you don't need to edit notes\n"
	"						tune[curTuneId].key = copyKey(keys[nextKeyId]);\n"
	"					}\n"
	"\n"
	"					refreshGameData();\n"
	"					redrawBackground = true;\n"
	"					redrawForeground = true;\n"
	"\n"
	"					curKeyId = nextKeyId;\n"
	"				}\n"
	"			},\n"
	"		});\n"
	"\n"
	"		tool.menu.pop({ control: \"group\" });\n"
	"	}\n"
	"}\n"
	"\n"
	"function getNoteSample(bar, start, end) {\n"
	"	var notes = [];\n"
	"	for (var i = 0; i < barLength; i++) {\n"
	"		// test for note in sample range\n"
	"		var isInSampleRange =\n"
	"			!(bar[i].beats <= 0) && 				// must *not* be a rest\n"
	"			(i <= end) && 							// AND must start before the sample range ends\n"
	"			!((i + (bar[i].beats - 1)) < start); 	// AND must *not* end before the sample range starts\n"
	"\n"
	"		if (isInSampleRange) {\n"
	"			notes.push(bar[i].note);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (notes.length <= 0) {\n"
	"		return null;\n"
	"	}\n"
	"\n"
	"	var average = 0;\n"
	"	for (var i = 0; i < notes.length; i++) {\n"
	"		average += notes[i];\n"
	"	}\n"
	"	average /= notes.length;\n"
	"\n"
	"	return Math.floor(average);\n"
	"}\n"
	"\n"
	"function drawBarPreview(tileId, bar, isSolfa, isSelected) {\n"
	"	var bgc = isSelected ? (tileColorStartIndex + 2) : (tileColorStartIndex + 1);\n"
	"	bitsy.fill(tileId, isSelected ? bgc : tileColorStartIndex);\n"
	"\n"
	"	// bar background\n"
	"	for (var y = 0; y < 6; y++) {\n"
	"		for (var x = 0; x < 6; x++) {\n"
	"			var pixel = ((y + 1) * bitsy.TILE_SIZE) + (x + 1);\n"
	"			bitsy.set(tileId, pixel, bgc);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// sampled notes\n"
	"	var sampleRanges = [[0, 1], [2, 3], [4, 7], [8, 11], [12, 13], [14, 15]];\n"
	"	var noteCount = isSolfa ? Solfa.COUNT : Note.COUNT;\n"
	"	for (var i = 0; i < sampleRanges.length; i++) {\n"
	"		var range = sampleRanges[i];\n"
	"		var sample = getNoteSample(bar, range[0], range[1]);\n"
	"		if (sample != null) {\n"
	"			var x = Math.floor(i);\n"
	"			var y = Math.floor((1 - (sample / (noteCount - 1))) * 5);\n"
	"			var pixel = ((y + 1) * bitsy.TILE_SIZE) + (x + 1);\n"
	"			bitsy.set(tileId, pixel, tileColorStartIndex);\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function updateBarPreviewTiles() {\n"
	"	bitsy.log(\"UPDATE BAR PREVIEW TILES\");\n"
	"	if (!tune[curTuneId]) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var isSolfa = (tune[curTuneId].key != undefined && tune[curTuneId].key != null);\n"
	"\n"
	"	// melody\n"
	"	for (var i = 0; i < tune[curTuneId].melody.length; i++) {\n"
	"		var tId = melodyBarTileIds[i];\n"
	"		drawBarPreview(tId, tune[curTuneId].melody[i], isSolfa, (i === curBarIndex && isMelody));\n"
	"	}\n"
	"\n"
	"	// harmony\n"
	"	for (var i = 0; i < tune[curTuneId].melody.length; i++) {\n"
	"		var tId = harmonyBarTileIds[i];\n"
	"		drawBarPreview(tId, tune[curTuneId].harmony[i], isSolfa, (i === curBarIndex && !isMelody));\n"
	"	}\n"
	"}\n"
	"\n"
	"function draw(tileName, x, y, map) {\n"
	"	map = (map != undefined) ? map : bitsy.MAP1;\n"
	"	var tileId = tool.world.names.tile[tileName];\n"
	"	var tile = tool.world.tile[tileId];\n"
	"	var frame = tool.renderer.GetDrawingFrame(tile, 0);\n"
	"	setTile(map, x, y, frame);\n"
	"}\n"
	"\n"
	"function isNoteSharp(note) {\n"
	"	switch (note) {\n"
	"		case Note.C_SHARP:\n"
	"		case Note.D_SHARP:\n"
	"		case Note.F_SHARP:\n"
	"		case Note.G_SHARP:\n"
	"		case Note.A_SHARP:\n"
	"			return true;\n"
	"			break;\n"
	"		default:\n"
	"			return false;\n"
	"			break;\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawBarSelect() {\n"
	"	// melody bars\n"
	"	for (var i = 0; i < tune[curTuneId].melody.length; i++) {\n"
	"		setTile(bitsy.MAP2, barSelectX + i, 0, melodyBarTileIds[i]);\n"
	"	}\n"
	"\n"
	"	// harmony bars\n"
	"	for (var i = 0; i < tune[curTuneId].melody.length; i++) {\n"
	"		setTile(bitsy.MAP2, barSelectX + i, 1, harmonyBarTileIds[i]);\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawNoteIndicator(noteId, tilePos) {\n"
	"	// current note indicator\n"
	"	if (tool.mouse.hover() && noteId != undefined && noteId > Note.NONE && noteId <= Note.COUNT) {\n"
	"		var closeNote = closestNoteInKey(noteId, tune[curTuneId].key);\n"
	"		var isSharp = isNoteSharp(closeNote);\n"
	"		var x = 14;\n"
	"		var y = 0;\n"
	"\n"
	"		switch (closeNote) {\n"
	"			case Note.COUNT:\n"
	"			case Note.C:\n"
	"			case Note.C_SHARP:\n"
	"				draw(\"note_c\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.D:\n"
	"			case Note.D_SHARP:\n"
	"				draw(\"note_d\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.E:\n"
	"				draw(\"note_e\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.F:\n"
	"			case Note.F_SHARP:\n"
	"				draw(\"note_f\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.G:\n"
	"			case Note.G_SHARP:\n"
	"				draw(\"note_g\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.A:\n"
	"			case Note.A_SHARP:\n"
	"				draw(\"note_a\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"			case Note.B_SHARP:\n"
	"				draw(\"note_b\", x, y, bitsy.MAP2);\n"
	"				break;\n"
	"		}\n"
	"\n"
	"		draw(isNoteSharp(closeNote) ? \"sharp\" : \"empty\", x + 1, y, bitsy.MAP2);\n"
	"	}\n"
	"}\n"
	"\n"
	"function copyBar(srcBar, destBar) {\n"
	"	for (var i = 0; i < barLength; i++) {\n"
	"		// melody\n"
	"		tune[curTuneId].melody[destBar][i].beats = tune[curTuneId].melody[srcBar][i].beats;\n"
	"		tune[curTuneId].melody[destBar][i].note = tune[curTuneId].melody[srcBar][i].note;\n"
	"		tune[curTuneId].melody[destBar][i].octave = tune[curTuneId].melody[srcBar][i].octave;\n"
	"		tune[curTuneId].melody[destBar][i].blip = tune[curTuneId].melody[srcBar][i].blip;\n"
	"		// harmony\n"
	"		tune[curTuneId].harmony[destBar][i].beats = tune[curTuneId].harmony[srcBar][i].beats;\n"
	"		tune[curTuneId].harmony[destBar][i].note = tune[curTuneId].harmony[srcBar][i].note;\n"
	"		tune[curTuneId].harmony[destBar][i].octave = tune[curTuneId].harmony[srcBar][i].octave;\n"
	"		tune[curTuneId].harmony[destBar][i].blip = tune[curTuneId].harmony[srcBar][i].blip;\n"
	"	}\n"
	"}\n"
	"\n"
	"function updateBarSelect(isMouseDown, tilePos) {\n"
	"	if (tilePos.y < 2 && tilePos.x < tune[curTuneId].melody.length) {\n"
	"		tool.mouse.tooltip(\"bar \" + (tilePos.x + 1) + \" (\" + (tilePos.y === 0 ? \"melody\" : \"harmony\") + \")\");\n"
	"	}\n"
	"\n"
	"	if (!isMouseDown || prevIsMouseDown) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	if (tilePos.y < 2 && tilePos.x < tune[curTuneId].melody.length) {\n"
	"		curBarIndex = tilePos.x;\n"
	"		isMelody = (tilePos.y === 0);\n"
	"\n"
	"		redrawBarTiles = true;\n"
	"		redrawBackground = true;\n"
	"		redrawForeground = true;\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawMusicalStaff(barLineIndex) {\n"
	"	var key = null;\n"
	"	var keyScale = [];\n"
	"	if (tune[curTuneId]) {\n"
	"		key = tune[curTuneId].key;\n"
	"		if (key != null) {\n"
	"			keyScale = getScaleNotes(key);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	var maxOctave = (isMelody || tune[curTuneId].arpeggioPattern === ArpeggioPattern.OFF) ? Octave[5] : Octave[4];\n"
	"\n"
	"	for (var i = Note.C; i <= Note.COUNT; i++) {\n"
	"		for (var x = 0; x < 16; x++) {\n"
	"			var noteIndex = (i % Note.COUNT);\n"
	"			var y = staffY - i;\n"
	"			if (key === null || keyScale.indexOf(noteIndex) != -1) {\n"
	"				if (isNoteSharp(noteIndex)) {\n"
	"					draw((x % barLineIndex === 0) ? \"dotb4\" : \"dotb\", x, y);\n"
	"				}\n"
	"				else {\n"
	"					draw((x % barLineIndex === 0) ? \"dot4\" : \"dot\", x, y);\n"
	"				}\n"
	"			}\n"
	"			else if (x % barLineIndex === 0) {\n"
	"				draw(\"bar\", x, y);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawBarNotes(curBeat) {\n"
	"	if (!tune[curTuneId]) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	// key information\n"
	"	var key = tune[curTuneId].key;\n"
	"	var keyScale = [];\n"
	"	if (key != null) {\n"
	"		keyScale = getScaleNotes(key);\n"
	"	}\n"
	"\n"
	"	// bar notes\n"
	"	var bar = isMelody\n"
	"		? tune[curTuneId].melody[curBarIndex]\n"
	"		: tune[curTuneId].harmony[curBarIndex];\n"
	"\n"
	"	// draw beat indicator\n"
	"	if (curBeat != null && (curBarIndex === curBeat.bar)) {\n"
	"		var x = curBeat.beat;\n"
	"		for (var i = Note.C; i <= Note.COUNT; i++) {\n"
	"			var y = staffY - i;\n"
	"			draw(\"beat\", x, y, bitsy.MAP2);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// draw empty octaves\n"
	"	for (var i = 0; i < bar.length; i++) {\n"
	"		draw(\"oct\", i, 15, bitsy.MAP2);\n"
	"	}\n"
	"\n"
	"	var upperOctaveStart = isMelody ? Octave[5] : Octave[3];\n"
	"\n"
	"	// draw current bar notes\n"
	"	for (var i = 0; i < bar.length; i++) {\n"
	"		if (key === null || key.scale.indexOf(bar[i].note) != -1) {\n"
	"			var noteIndex = (key === null) ? bar[i].note : key.notes[bar[i].note];\n"
	"\n"
	"			// draw high C up on the top of the musical staff\n"
	"			if (noteIndex === Note.C && bar[i].octave >= upperOctaveStart) {\n"
	"				noteIndex += Note.COUNT;\n"
	"			}\n"
	"\n"
	"			if (bar[i].beats > 0) {\n"
	"				var isNotePlaying = (curBeat != null)\n"
	"					&& (curBarIndex === curBeat.bar)\n"
	"					&& (curBeat.beat >= i && curBeat.beat < i + bar[i].beats);\n"
	"\n"
	"				if (bar[i].blip != undefined) {\n"
	"					// todo : is it safe to remove this check now?\n"
	"					if (blipTileIds && blipInvertedTileIds) {\n"
	"						// blip\n"
	"						if (blipTileIds[i] === undefined) {\n"
	"							blipTileIds[i] = makeBlipTile(tool.soundPlayer, bar[i].blip, false);\n"
	"						}\n"
	"						if (blipInvertedTileIds[i] === undefined) {\n"
	"							blipInvertedTileIds[i] = makeBlipTile(tool.soundPlayer, bar[i].blip, true);\n"
	"						}\n"
	"\n"
	"						setTile(bitsy.MAP2, i, staffY - noteIndex, isNotePlaying ? blipInvertedTileIds[i] : blipTileIds[i]);\n"
	"					}\n"
	"				}\n"
	"				else if (bar[i].beats === 1) {\n"
	"					// short note\n"
	"					draw(isNotePlaying ? \"note2\" : \"note\", i, staffY - noteIndex, bitsy.MAP2);\n"
	"				}\n"
	"				else {\n"
	"					// long note\n"
	"					for (var j = 0; j < bar[i].beats; j++) {\n"
	"						if (j === 0) {\n"
	"							draw(isNotePlaying ? \"note4_l\" : \"note3_l\", i + j, staffY - noteIndex, bitsy.MAP2);\n"
	"						}\n"
	"						else if (j === bar[i].beats - 1) {\n"
	"							draw(isNotePlaying ? \"note4_r\" : \"note3_r\", i + j, staffY - noteIndex, bitsy.MAP2);\n"
	"						}\n"
	"						else {\n"
	"							draw(isNotePlaying ? \"note4\" : \"note3\", i + j, staffY - noteIndex, bitsy.MAP2);\n"
	"						}\n"
	"					}\n"
	"				}\n"
	"\n"
	"				draw(octaveTileNames[bar[i].octave], i, 15, bitsy.MAP2);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"}\n"
	"\n"
	"function drawArpeggio(curBeat) {\n"
	"	if (!tune[curTuneId] || isMelody) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var bar = tune[curTuneId].harmony[curBarIndex];\n"
	"	var key = tune[curTuneId].key;\n"
	"\n"
	"	if (key === null) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var tonic = bar[0];\n"
	"	var isArpeggioPlaying = (curBeat != null) && (curBarIndex === curBeat.bar);\n"
	"	var upperOctaveStart = Octave[3];\n"
	"\n"
	"	// tonic note select\n"
	"	if (tonic.beats > 0) {\n"
	"		var noteIndex = key.notes[tonic.note];\n"
	"		// draw high C up on the top of the musical staff\n"
	"		if (noteIndex === Note.C && tonic.octave >= upperOctaveStart) {\n"
	"			noteIndex += Note.COUNT;\n"
	"		}\n"
	"\n"
	"		for (var x = 0; x < 15; x++) {\n"
	"			if (x === 0) {\n"
	"				draw(isArpeggioPlaying ? \"note4_l\" : \"note3_l\", x, staffY - noteIndex, bitsy.MAP2);\n"
	"			}\n"
	"			else if (x === 14) {\n"
	"				draw(isArpeggioPlaying ? \"note4_r\" : \"note3_r\", x, staffY - noteIndex, bitsy.MAP2);\n"
	"			}\n"
	"			else {\n"
	"				draw(isArpeggioPlaying ? \"note4\" : \"note3\", x, staffY - noteIndex, bitsy.MAP2);\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// arpeggio pattern\n"
	"	if (tonic.beats > 0) {\n"
	"		var arpeggioSteps = soundPlayer.getArpeggioSteps(tune[curTuneId]);\n"
	"		for (var i = 0; i < arpeggioSteps.length; i++) {\n"
	"			var noteIndex = key.notes[arpeggioSteps[i] % Solfa.COUNT];\n"
	"			if (arpeggioSteps[i] >= Solfa.COUNT) {\n"
	"				noteIndex += Note.COUNT;\n"
	"			}\n"
	"			var isNotePlaying = (isArpeggioPlaying && (curBeat.beat % arpeggioSteps.length) === i);\n"
	"			draw(isNotePlaying ? \"note2\" : \"note\", 15, staffY - noteIndex, bitsy.MAP2);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// octave\n"
	"	if (tonic.beats > 0) {\n"
	"		draw(octaveTileNames[tonic.octave], 0, 15, bitsy.MAP2);\n"
	"	}\n"
	"	else {\n"
	"		draw(\"oct\", 0, 15, bitsy.MAP2);\n"
	"	}\n"
	"}\n"
	"\n"
	"function eraseNotesInRange(startIndex, endIndex) {\n"
	"	var curTune = tune[curTuneId];\n"
	"	var curBar = isMelody\n"
	"		? curTune.melody[curBarIndex]\n"
	"		: curTune.harmony[curBarIndex];\n"
	"\n"
	"	for (var i = 0; i < 16; i++) {\n"
	"		if (curBar[i].beats > 0) {\n"
	"			var note = curBar[i];\n"
	"			var noteStart = i;\n"
	"			var noteEnd = i + note.beats - 1;\n"
	"\n"
	"			if (noteStart >= startIndex && noteEnd <= endIndex) {\n"
	"				// if the eraser range contains the entire note, erase it\n"
	"				note.beats = 0;\n"
	"			}\n"
	"			else if (noteStart < startIndex && noteEnd > endIndex) {\n"
	"				// if the *note* contains the eraser range, split the note in two\n"
	"				curBar[endIndex + 1].note = note.note;\n"
	"				curBar[endIndex + 1].octave = note.octave;\n"
	"				curBar[endIndex + 1].beats = noteEnd - endIndex;\n"
	"				note.beats = startIndex - noteStart;\n"
	"			}\n"
	"			else if (noteStart >= startIndex && noteStart <= endIndex) {\n"
	"				// if the eraser range contains the note's start, move and shrink the note\n"
	"				curBar[endIndex + 1].note = note.note;\n"
	"				curBar[endIndex + 1].octave = note.octave;\n"
	"				curBar[endIndex + 1].beats = noteEnd - endIndex;\n"
	"				note.beats = 0;\n"
	"			}\n"
	"			else if (noteEnd >= startIndex && noteEnd <= endIndex) {\n"
	"				// if the eraser range contains the note's end, shrink the note\n"
	"				note.beats = startIndex - noteStart;\n"
	"			}\n"
	"		}\n"
	"	}\n"
	"\n"
	"	redrawForeground = true;\n"
	"	redrawBarTiles = true;\n"
	"}\n"
	"\n"
	"function updateBarNotes(isMouseDown, tilePos, noteId) {\n"
	"	if (isPlayMode || tune[curTuneId] === undefined || isMusicPlaying) {\n"
	"		curEditMode = NOTE_EDIT.NONE;\n"
	"		noteEdit.startIndex = null;\n"
	"		noteEdit.endIndex = null;\n"
	"		noteEdit.curNoteId = null;\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var curTune = tune[curTuneId];\n"
	"	var curBar = isMelody\n"
	"		? curTune.melody[curBarIndex]\n"
	"		: curTune.harmony[curBarIndex];\n"
	"	var curKey = curTune.key;\n"
	"	var beatIndex = tilePos.x;\n"
	"\n"
	"	if (noteId > Note.NONE && noteId < Note.COUNT) {\n"
	"		var tooltip = \"beat \" + Math.floor((beatIndex / 4) + 1) + \".\" + Math.floor((beatIndex % 4) + 1);\n"
	"\n"
	"		if (curBar[beatIndex] && curBar[beatIndex].beats > 0) {\n"
	"			if (curBar[beatIndex].blip) {\n"
	"				var blipId = curBar[beatIndex].blip;\n"
	"				tooltip += \": \";\n"
	"				if (blip[blipId].name) {\n"
	"					tooltip += blip[blipId].name;\n"
	"				}\n"
	"				else {\n"
	"					tooltip += \"blip \" + blipId;\n"
	"				}\n"
	"			}\n"
	"			else {\n"
	"				tooltip += \" (note: \" + serializeNote(\n"
	"					curBar[beatIndex].note,\n"
	"					tune[curTuneId].key,\n"
	"					true /* useFriendlyName */) + \")\";\n"
	"			}\n"
	"		}\n"
	"\n"
	"		tool.mouse.tooltip(tooltip);\n"
	"	}\n"
	"	else if (tilePos.y === 15 && curBar[beatIndex] && curBar[beatIndex].beats > 0) {\n"
	"		tool.mouse.tooltip(\"octave \" + (curBar[beatIndex].octave + 2) + \" (tap to cycle)\"); \n"
	"	}\n"
	"\n"
	"	if (isMouseDown && !prevIsMouseDown) {\n"
	"		if (noteId > Note.NONE && noteId <= Note.COUNT) {\n"
	"			noteEdit.startIndex = beatIndex;\n"
	"			noteEdit.endIndex = beatIndex;\n"
	"			noteEdit.curNoteId = closestNoteInKey(noteId, curKey);\n"
	"\n"
	"			var collideNote = null;\n"
	"			for (var i = 0; i < 16; i++) {\n"
	"				if (curBar[i].beats > 0 && beatIndex >= i && beatIndex < i + curBar[i].beats) {\n"
	"					collideNote = curBar[i].note;\n"
	"\n"
	"					// convert solfa notes to chromatic\n"
	"					if (curKey != null) {\n"
	"						collideNote = curKey.notes[collideNote];\n"
	"					}\n"
	"				}\n"
	"			}\n"
	"\n"
	"			if (collideNote != null && (collideNote % Note.COUNT) === (noteEdit.curNoteId % Note.COUNT)) {\n"
	"				eraseNotesInRange(noteEdit.startIndex, noteEdit.endIndex);\n"
	"				refreshGameData();\n"
	"				curEditMode = NOTE_EDIT.REMOVE;\n"
	"			}\n"
	"			else {\n"
	"				setNote(noteEdit.startIndex, noteEdit.curNoteId, { noteMode: curNoteMode, });\n"
	"				curEditMode = NOTE_EDIT.ADD;\n"
	"			}\n"
	"		}\n"
	"		else if (tilePos.y === 15 && curBar[beatIndex].beats > 0) {\n"
	"			// octave cycle\n"
	"			curBar[beatIndex].octave++;\n"
	"			if (curBar[beatIndex].octave > Octave[5]) {\n"
	"				curBar[beatIndex].octave = Octave[2];\n"
	"			}\n"
	"\n"
	"			if (!isMusicPlaying) { // HACK!\n"
	"				// play note or blip\n"
	"				if (curBar[beatIndex].blip) {\n"
	"					var curBlip = blip[curBar[beatIndex].blip];\n"
	"					tool.soundPlayer.playBlip(curBlip, { pitch: curBar[beatIndex] });\n"
	"				}\n"
	"				else {\n"
	"					tool.soundPlayer.playNote(\n"
	"						{ beats: 1, note: curBar[beatIndex].note, octave: curBar[beatIndex].octave, },\n"
	"						isMelody ? curTune.instrumentA : curTune.instrumentB,\n"
	"						bitsy.SOUND1,\n"
	"						curTune.key);\n"
	"				}\n"
	"			}\n"
	"\n"
	"			refreshGameData();\n"
	"\n"
	"			curEditMode = NOTE_EDIT.NONE;\n"
	"		}\n"
	"	}\n"
	"	else if (isMouseDown) {\n"
	"		// disable click and drag for notes with effects\n"
	"		if (curNoteMode === NOTE_TYPE.BLIP) {\n"
	"			curEditMode = NOTE_EDIT.NONE;\n"
	"		}\n"
	"\n"
	"		if (curEditMode === NOTE_EDIT.ADD) {\n"
	"			if (noteId > Note.NONE && noteId <= Note.COUNT) {\n"
	"				noteId = closestNoteInKey(noteId, curKey);\n"
	"				if (noteId != noteEdit.curNoteId) {\n"
	"					// new note: start drag over\n"
	"					noteEdit.startIndex = tilePos.x;\n"
	"					noteEdit.endIndex = noteEdit.startIndex;\n"
	"					noteEdit.curNoteId = noteId;\n"
	"					setNote(noteEdit.startIndex, noteEdit.curNoteId, { noteMode: curNoteMode, });\n"
	"				}\n"
	"				else if (tilePos.x < noteEdit.startIndex) {\n"
	"					noteEdit.startIndex = tilePos.x;\n"
	"					setNote(\n"
	"						noteEdit.startIndex,\n"
	"						noteEdit.curNoteId,\n"
	"						{ noteMode: curNoteMode, beats: (noteEdit.endIndex - noteEdit.startIndex + 1), });\n"
	"				}\n"
	"				else if (tilePos.x > noteEdit.endIndex) {\n"
	"					noteEdit.endIndex = tilePos.x;\n"
	"					setNote(\n"
	"						noteEdit.startIndex,\n"
	"						noteEdit.curNoteId,\n"
	"						{ noteMode: curNoteMode, beats: (noteEdit.endIndex - noteEdit.startIndex + 1), });\n"
	"				}\n"
	"			}\n"
	"		}\n"
	"		else if (curEditMode === NOTE_EDIT.REMOVE) {\n"
	"			if (tilePos.x < noteEdit.startIndex) {\n"
	"				noteEdit.startIndex = tilePos.x;\n"
	"			}\n"
	"			else if (tilePos.x > noteEdit.endIndex) {\n"
	"				noteEdit.endIndex = tilePos.x;\n"
	"			}\n"
	"			eraseNotesInRange(noteEdit.startIndex, noteEdit.endIndex);\n"
	"			refreshGameData();\n"
	"		}\n"
	"	}\n"
	"	else if (!isMouseDown && prevIsMouseDown) {\n"
	"		redrawBarTiles = true;\n"
	"		redrawForeground = true;\n"
	"\n"
	"		curEditMode = NOTE_EDIT.NONE;\n"
	"		noteEdit.startIndex = null;\n"
	"		noteEdit.endIndex = null;\n"
	"		noteEdit.curNoteId = null;\n"
	"	}\n"
	"}\n"
	"\n"
	"function updateArpeggio(isMouseDown, tilePos, noteId) {\n"
	"	if (!tune[curTuneId] || isMelody || isMusicPlaying) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	var bar = tune[curTuneId].harmony[curBarIndex];\n"
	"	var key = tune[curTuneId].key;\n"
	"\n"
	"	if (key === null) {\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	tool.mouse.tooltip(\"click to select the tonic note for an arpeggio\");\n"
	"\n"
	"	if (isMouseDown && !prevIsMouseDown) {\n"
	"		if (noteId != undefined && noteId > Note.NONE && noteId <= Note.COUNT && tilePos.x < 15) {\n"
	"			// set the arpeggio tonic note\n"
	"			var closeNote = closestNoteInKey(noteId, key);\n"
	"			var octave = (closeNote >= Note.COUNT) ? Octave[3] : Octave[2];\n"
	"			var solfaNote = key.notes.indexOf(closeNote % Note.COUNT);\n"
	"			var tonic = {\n"
	"				beats: 16, // fill the whole bar\n"
	"				note: solfaNote,\n"
	"				octave: octave\n"
	"			};\n"
	"			curEditMode = setArpeggioTonic(tonic);\n"
	"		}\n"
	"		else if (tilePos.y === 15 && tilePos.x === 0 && bar[0].beats > 0) {\n"
	"			// octave cycle\n"
	"			var tonic = { \n"
	"				beats: 16,\n"
	"				note: bar[0].note,\n"
	"				octave: bar[0].octave\n"
	"			};\n"
	"			tonic.octave++;\n"
	"			if (tonic.octave > Octave[4]) {\n"
	"				tonic.octave = Octave[2];\n"
	"			}\n"
	"			curEditMode = setArpeggioTonic(tonic);\n"
	"		}\n"
	"\n"
	"		redrawBarTiles = true;\n"
	"		redrawForeground = true;\n"
	"	}\n"
	"}\n"
	"\n"
	"var isPaletteLoaded = false;\n"
	"var redrawBarTiles = true;\n"
	"var redrawBackground = true;\n"
	"var redrawForeground = true;\n"
	"var prevBeat = null;\n"
	"var prevTilePos = null;\n"
	"\n"
	"function update(dt) {\n"
	"	if (!tune[curTuneId]) {\n"
	"		return true;\n"
	"	}\n"
	"\n"
	"	// also kind of hacky??\n"
	"	// todo : also I don't think it works quite right..\n"
	"	if (isPlayMode && isMusicPlaying) {\n"
	"		tool.soundPlayer.stopTune();\n"
	"		isMusicPlaying = false;\n"
	"	}\n"
	"\n"
	"	if (!isPlayMode) {\n"
	"		tool.soundPlayer.update(dt);\n"
	"	}\n"
	"\n"
	"	if (!isPaletteLoaded) {\n"
	"		bitsy.log(\"load palette\");\n"
	"		updatePaletteWithTileColors(tool.world.palette[\"0\"].colors);\n"
	"		isPaletteLoaded = true;\n"
	"	}\n"
	"\n"
	"	// mouse input\n"
	"	var isMouseDown = tool.mouse.down();\n"
	"	var mousePos = tool.mouse.pos();\n"
	"	var tilePos = {\n"
	"		x: Math.floor(mousePos.x / tilesize),\n"
	"		y: Math.floor(mousePos.y / tilesize),\n"
	"	};\n"
	"	var noteId = (staffY - tilePos.y);\n"
	"\n"
	"	bitsy.graphicsMode(bitsy.GFX_MAP);\n"
	"\n"
	"	// initialize bar tiles\n"
	"	if (melodyBarTileIds === null) {\n"
	"		melodyBarTileIds = [];\n"
	"		for (var i = 0; i < maxTuneLength; i++) {\n"
	"			melodyBarTileIds.push(bitsy.tile());\n"
	"		}\n"
	"	}\n"
	"	if (harmonyBarTileIds === null) {\n"
	"		harmonyBarTileIds = [];\n"
	"		for (var i = 0; i < maxTuneLength; i++) {\n"
	"			harmonyBarTileIds.push(bitsy.tile());\n"
	"		}\n"
	"	}\n"
	"\n"
	"	if (redrawBarTiles) {\n"
	"		updateBarPreviewTiles();\n"
	"		redrawBarTiles = false;\n"
	"	}\n"
	"\n"
	"	// redraw the foreground when the mouse moves to a different tile\n"
	"	if (isMouseDown || JSON.stringify(tilePos) != JSON.stringify(prevTilePos)) {\n"
	"		redrawForeground = true;\n"
	"	}\n"
	"\n"
	"	var curBeat = tool.soundPlayer.getBeat();\n"
	"	if (curBeat != null || prevBeat != null) {\n"
	"		// todo : this is kind of silly way to make this comparison probably\n"
	"		var isNextBeat = JSON.stringify(curBeat) != JSON.stringify(prevBeat);\n"
	"		if (isNextBeat) {\n"
	"			redrawForeground = true;\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// draw background\n"
	"	if (redrawBackground) {\n"
	"		bitsy.fill(bitsy.MAP1, 0);\n"
	"		if (tune[curTuneId].arpeggioPattern != ArpeggioPattern.OFF && !isMelody) {\n"
	"			drawMusicalStaff(15);\n"
	"\n"
	"			// clear the last column for the pattern preview\n"
	"			for (var i = 0; i < bitsy.MAP_SIZE; i++) {\n"
	"				setTile(bitsy.MAP1, 15, i, 0);\n"
	"			}\n"
	"		}\n"
	"		else {\n"
	"			drawMusicalStaff(4);\n"
	"		}\n"
	"		redrawBackground = false;\n"
	"	}\n"
	"\n"
	"	// draw foreground\n"
	"	if (redrawForeground) {\n"
	"		bitsy.fill(bitsy.MAP2, 0);\n"
	"		drawBarSelect();\n"
	"		if (tune[curTuneId].arpeggioPattern != ArpeggioPattern.OFF && !isMelody) {\n"
	"			drawArpeggio(curBeat);\n"
	"		}\n"
	"		else {\n"
	"			drawBarNotes(curBeat);\n"
	"		}\n"
	"		drawNoteIndicator(noteId, tilePos);\n"
	"		redrawForeground = false;\n"
	"	}\n"
	"\n"
	"	// input\n"
	"	updateBarSelect(isMouseDown, tilePos);\n"
	"	if (tune[curTuneId].arpeggioPattern != ArpeggioPattern.OFF && !isMelody) {\n"
	"		updateArpeggio(isMouseDown, tilePos, noteId);\n"
	"	}\n"
	"	else {\n"
	"		updateBarNotes(isMouseDown, tilePos, noteId);\n"
	"	}\n"
	"\n"
	"	prevPlayMode = isPlayMode;\n"
	"	prevIsMouseDown = isMouseDown;\n"
	"	prevBeat = curBeat;\n"
	"	prevTilePos = tilePos;\n"
	"\n"
	"	return true;\n"
	"}\n"
	"\n"
	"tool.loop = update;\n"
	"tool.menuUpdate = menuUpdate;\n"
	"\n"
	"// todo : name?\n"
	"tool.onSelect = function(id) {\n"
	"	curTuneId = id;\n"
	"	curBarIndex = 0;\n"
	"	isMelody = true;\n"
	"	curKeyId = MusicalKey.CHROMATIC;\n"
	"\n"
	"	if (curTuneId && tune[curTuneId] && tune[curTuneId].key != null) {\n"
	"		curKeyId = getKeyId(tune[curTuneId].key);\n"
	"	}\n"
	"\n"
	"	redrawBarTiles = true;\n"
	"	redrawBackground = true;\n"
	"	redrawForeground = true;\n"
	"\n"
	"	if (isMusicPlaying) {\n"
	"		tool.soundPlayer.stopTune();\n"
	"		isMusicPlaying = false;\n"
	"	}\n"
	"};\n"
	"\n"
	"tool.add = function() {\n"
	"	// should the next ID logic be in the find tool?\n"
	"	var nextId = \"1\"; // hacky way to specify the default id..\n"
	"	var idList = sortedBase36IdList(tune);\n"
	"	if (idList.length > 0) {\n"
	"		nextId = nextObjectId(idList);\n"
	"	}\n"
	"\n"
	"	tune[nextId] = createTuneData(nextId);\n"
	"\n"
	"	// pick random square wave for instrument A\n"
	"	tune[nextId].instrumentA = Math.floor(Math.random() * SquareWave.COUNT);\n"
	"\n"
	"	// pick random square wave that's *different* from instrument A for instrument B\n"
	"	tune[nextId].instrumentB = ((tune[nextId].instrumentA + 1)\n"
	"		+ Math.floor(Math.random() * (SquareWave.COUNT - 1))) % SquareWave.COUNT;\n"
	"\n"
	"	// hacky: need to have the tempo enum use integer values\n"
	"	var tempo = [Tempo.SLW, Tempo.MED, Tempo.FST][Math.floor(Math.random() * 3)];\n"
	"	tune[nextId].tempo = tempo;\n"
	"\n"
	"	var key = Math.random() > 0.5 ? MusicalKey.MINOR_PENTATONIC : MusicalKey.MAJOR_PENTATONIC;\n"
	"	tune[nextId].key = copyKey(keys[key]);\n"
	"\n"
	"	var arp = ArpeggioPattern.UP + Math.floor(Math.random() * ArpeggioPattern.INT8);\n"
	"	tune[nextId].arpeggioPattern = arp;\n"
	"\n"
	"	// start with four empty bars\n"
	"	for (var i = 0; i < 4; i++) {\n"
	"		// create empty melody & harmony bars\n"
	"		tune[nextId].melody.push(createTuneBarData());\n"
	"		tune[nextId].harmony.push(createTuneBarData());\n"
	"	}\n"
	"};\n"
	"\n"
	"tool.duplicate = function(id) {\n"
	"	var nextId = nextObjectId(sortedBase36IdList(tune));\n"
	"	tune[nextId] = createTuneData(nextId);\n"
	"\n"
	"	// copy settings\n"
	"	tune[nextId].key = copyKey(tune[id].key);\n"
	"	tune[nextId].tempo = tune[id].tempo;\n"
	"	tune[nextId].instrumentA = tune[id].instrumentA;\n"
	"	tune[nextId].instrumentB = tune[id].instrumentB;\n"
	"	tune[nextId].arpeggioPattern = tune[id].arpeggioPattern;\n"
	"\n"
	"	// copy bars\n"
	"	for (var i = 0; i < tune[id].melody.length; i++) {\n"
	"		tune[nextId].melody.push(createTuneBarData());\n"
	"		tune[nextId].harmony.push(createTuneBarData());\n"
	"		for (var j = 0; j < 16; j++) {\n"
	"			// melody\n"
	"			tune[nextId].melody[i][j].note = tune[id].melody[i][j].note;\n"
	"			tune[nextId].melody[i][j].octave = tune[id].melody[i][j].octave;\n"
	"			tune[nextId].melody[i][j].beats = tune[id].melody[i][j].beats;\n"
	"			// harmony\n"
	"			tune[nextId].harmony[i][j].note = tune[id].harmony[i][j].note;\n"
	"			tune[nextId].harmony[i][j].octave = tune[id].harmony[i][j].octave;\n"
	"			tune[nextId].harmony[i][j].beats = tune[id].harmony[i][j].beats;\n"
	"		}\n"
	"	}\n"
	"};\n"
	"\n"
	"tool.delete = function(id) {\n"
	"	if (sortedBase36IdList(tune).length <= 1) {\n"
	"		alert(\"you can't delete your last tune!\");\n"
	"		return;\n"
	"	}\n"
	"\n"
	"	delete tune[id];\n"
	"};\n"
	"\n"
	"tool.onGameDataChange = function() {\n"
	"	// force render refresh // todo : need to think about the architecture of sharing renderers\n"
	"	if (tool && tool.renderer) {\n"
	"		tool.renderer.ClearCache();\n"
	"		melodyBarTileIds = null;\n"
	"		harmonyBarTileIds = null;\n"
	"		blipTileIds = [];\n"
	"		blipInvertedTileIds = [];\n"
	"	}\n"
	"};\n";

char* tool_demo_js =
	"bitsy.log(\"~ initializing tool demo ~\");\n"
	"\n"
	"// bitsybox interop\n"
	"var __bitsybox_should_quit_tool_demo__ = false;\n"
	"\n"
	"// global settings\n"
	"var isPlayMode = false;\n"
	"var tilesize = 8;\n"
	"function refreshGameData() {};\n"
	"\n"
	"// mouse input\n"
	"var enableTooltipLog = false;\n"
	"var enableMouseInput = true;\n"
	"var mouse = {\n"
	"	hover: function() { return enableMouseInput && __bitsybox_mouse_hover__; },\n"
	"	down: function() { return enableMouseInput && __bitsybox_mouse_down__; },\n"
	"	pos: function() { return { x: __bitsybox_mouse_x__, y: __bitsybox_mouse_y__, }; },\n"
	"	alt: function() { return enableMouseInput && __bitsybox_mouse_alt__; },\n"
	"	tooltip: function(text) {\n"
	"		if (enableTooltipLog) {\n"
	"			bitsy.log(\"tooltip: \" + text);\n"
	"		}\n"
	"	},\n"
	"}\n"
	"\n"
	"// localization system stub\n"
	"var localization = {\n"
	"	GetStringOrFallback(id, fallback) { return fallback; },\n"
	"};\n"
	"\n"
	"// menu system\n"
	"var dialogModule = new Dialog();\n"
	"var dialogRenderer = dialogModule.CreateRenderer();\n"
	"var dialogBuffer = dialogModule.CreateBuffer();\n"
	"var fontManager = new FontManager();\n"
	"\n"
	"var isMenuActive = false;\n"
	"var menuControls = [];\n"
	"var menuItemIndex = 0;\n"
	"var menuString = \"\";\n"
	"var cursorClickAnimCounter = 0;\n"
	"\n"
	"var menu = {\n"
	"	push: function(control) {\n"
	"		// skip groups because they're non-interactive\n"
	"		if (control.control != \"group\") {\n"
	"			menuControls.push(control)\n"
	"		}\n"
	"	},\n"
	"	pop: function() {\n"
	"		// TODO\n"
	"	},\n"
	"};\n"
	"\n"
	"// input state\n"
	"var isUpButtonHeld = false\n"
	"var isDownButtonHeld = false;\n"
	"var isLeftButtonHeld = false;\n"
	"var isRightButtonHeld = false;\n"
	"var isOkButtonHeld = false;\n"
	"var isMenuButtonHeld = false;\n"
	"\n"
	"// intialize tool object\n"
	"var tool = {\n"
	"	world: null,\n"
	"	mouse: mouse,\n"
	"	menu: menu,\n"
	"	renderer: new TileRenderer(\"TOOL_DEMO\"),\n"
	"};\n"
	"\n"
	"function stringifyMenu(menuControls) {\n"
	"	var visited = [];\n"
	"\n"
	"	return JSON.stringify(menuControls, function(key, value) {\n"
	"		// skip already visited objects to avoid cycles\n"
	"		if (value != null && typeof(value) === \"object\") {\n"
	"			if (visited.indexOf(value) >= 0) {\n"
	"				return;\n"
	"			}\n"
	"\n"
	"			visited.push(value);\n"
	"		}\n"
	"\n"
	"		return value;\n"
	"	});\n"
	"}\n"
	"\n"
	"// update loop\n"
	"bitsy.loop(function(dt) {\n"
	"	if (!tool.world) {\n"
	"		// parse tool data\n"
	"		tool.world = parseWorld(bitsy.getGameData());\n"
	"\n"
	"		// give drawing data to the renderer\n"
	"		tool.renderer.SetDrawings(tool.world.drawings);\n"
	"\n"
	"		// hack: copy tunes from the tool data to global data so we have something to play in the demo\n"
	"		tune = tool.world.tune;\n"
	"\n"
	"		// select tune 0\n"
	"		tool.onSelect(\"0\");\n"
	"\n"
	"		// load default font\n"
	"		var fontData = bitsy.getFontData();\n"
	"		fontManager.AddResource(tool.world.fontName + fontManager.GetExtension(), fontData);\n"
	"		var font = fontManager.Get(tool.world.fontName);\n"
	"\n"
	"		// initialize dialog system\n"
	"		dialogBuffer.Reset();\n"
	"		dialogBuffer.SetFont(font);\n"
	"		dialogRenderer.SetFont(font);\n"
	"		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());\n"
	"	}\n"
	"\n"
	"	enableMouseInput = true;\n"
	"\n"
	"	// if it's active, update the tool menu\n"
	"	if (isMenuActive && tool.menuUpdate) {\n"
	"		// disable the mouse while the menu is open\n"
	"		enableMouseInput = false;\n"
	"\n"
	"		// update menu state\n"
	"		var prevMenuString = menuString;\n"
	"		menuControls = [];\n"
	"		tool.menuUpdate(dt);\n"
	"		menuString = stringifyMenu(menuControls);\n"
	"\n"
	"		// update menu input\n"
	"		var prevMenuItemIndex = menuItemIndex;\n"
	"		if (bitsy.button(bitsy.BTN_UP) && !isUpButtonHeld && menuItemIndex > 0) {\n"
	"			menuItemIndex--;\n"
	"		}\n"
	"		else if (bitsy.button(bitsy.BTN_DOWN) && !isDownButtonHeld && menuItemIndex < (menuControls.length - 1)) {\n"
	"			menuItemIndex++;\n"
	"		}\n"
	"\n"
	"		var didCursorClick = false;\n"
	"		if ((bitsy.button(bitsy.BTN_RIGHT) && !isRightButtonHeld) || (bitsy.button(bitsy.BTN_OK) && !isOkButtonHeld)) {\n"
	"			var selectedControl = menuControls[menuItemIndex];\n"
	"			if (selectedControl.control === \"button\") {\n"
	"				if (selectedControl.onclick) {\n"
	"					selectedControl.onclick();\n"
	"				}\n"
	"\n"
	"				didCursorClick = true;\n"
	"			}\n"
	"			else if (selectedControl.control === \"toggle\") {\n"
	"				var nextChecked = !selectedControl.checked;\n"
	"				if (selectedControl.onclick) {\n"
	"					var event = { target: { checked: nextChecked, }, };\n"
	"					selectedControl.onclick(event);						\n"
	"				}\n"
	"\n"
	"				didCursorClick = true;\n"
	"			}\n"
	"			else if (selectedControl.control === \"select\") {\n"
	"				var nextValue = (selectedControl.value + 1) % selectedControl.options.length;\n"
	"				if (selectedControl.onchange) {\n"
	"					var event = { target: { value: nextValue, }, };\n"
	"					selectedControl.onchange(event);\n"
	"				}\n"
	"\n"
	"				didCursorClick = true;\n"
	"			}\n"
	"		}\n"
	"		else if (bitsy.button(bitsy.BTN_LEFT) && !isLeftButtonHeld) {\n"
	"			var selectedControl = menuControls[menuItemIndex];\n"
	"			if (selectedControl.control === \"select\") {\n"
	"				var nextValue = (selectedControl.value - 1);\n"
	"				if (nextValue < 0) {\n"
	"					nextValue = selectedControl.options.length - 1;\n"
	"				}\n"
	"				if (selectedControl.onchange) {\n"
	"					var event = { target: { value: nextValue, }, };\n"
	"					selectedControl.onchange(event);\n"
	"				}\n"
	"\n"
	"				didCursorClick = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// keep the menu index in range\n"
	"		if (menuItemIndex < 0) {\n"
	"			menuItemIndex = 0;\n"
	"		}\n"
	"		else if (menuItemIndex >= menuControls.length) {\n"
	"			menuItemIndex = menuControls.length - 1;\n"
	"		}\n"
	"\n"
	"		// update click animation counter\n"
	"		var didCursorChange = false;\n"
	"		if (didCursorClick) {\n"
	"			cursorClickAnimCounter = 100;\n"
	"			didCursorChange = true;\n"
	"		}\n"
	"		else if (cursorClickAnimCounter > 0) {			\n"
	"			cursorClickAnimCounter -= dt;\n"
	"			if (cursorClickAnimCounter <= 0) {\n"
	"				cursorClickAnimCounter = 0;\n"
	"				didCursorChange = true;\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// update menu UI\n"
	"		if (menuString != prevMenuString || prevMenuItemIndex != menuItemIndex || didCursorChange)\n"
	"		{\n"
	"			dialogRenderer.Reset();\n"
	"			dialogRenderer.SetCentered(true);\n"
	"			dialogBuffer.Reset();\n"
	"\n"
	"			for (var i = 0; i < menuControls.length; i++) {\n"
	"				var control = menuControls[i];\n"
	"\n"
	"				if (i == menuItemIndex) {\n"
	"					dialogBuffer.AddDrawing(cursorClickAnimCounter > 0 ? \"SPR_c\" : \"SPR_b\", tool.renderer);\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"\n"
	"				dialogBuffer.AddText(\" \");\n"
	"				dialogBuffer.Skip();\n"
	"\n"
	"				if (control.control === \"toggle\" && control.checked != undefined && control.checked) {\n"
	"					dialogBuffer.AddText(\"[ \");\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"\n"
	"				if (control.icon != undefined) {\n"
	"					var iconTileName = \"icon_\" + control.icon;\n"
	"					var iconTileId = tool.world.names.tile[iconTileName];\n"
	"					dialogBuffer.AddDrawing(\"TIL_\" + iconTileId, tool.renderer);\n"
	"					dialogBuffer.Skip();\n"
	"\n"
	"					dialogBuffer.AddText(\" \");\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"\n"
	"				if (control.text != undefined) {\n"
	"					dialogBuffer.AddText(control.text + \" \");\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"\n"
	"				if (control.value != undefined) {\n"
	"					if (control.control === \"select\") {\n"
	"						dialogBuffer.AddText(\"< \");\n"
	"						dialogBuffer.Skip();\n"
	"\n"
	"						var selectedOption;\n"
	"						for (var j = 0; j < control.options.length; j++) {\n"
	"							var controlOption = control.options[j];\n"
	"							if (controlOption.value === control.value) {\n"
	"								selectedOption = controlOption;\n"
	"							}\n"
	"						}\n"
	"\n"
	"						if (selectedOption) {\n"
	"							if (selectedOption.icon != undefined) {\n"
	"								var iconTileName = \"icon_\" + selectedOption.icon;\n"
	"								var iconTileId = tool.world.names.tile[iconTileName];\n"
	"								dialogBuffer.AddDrawing(\"TIL_\" + iconTileId, tool.renderer);\n"
	"								dialogBuffer.Skip();\n"
	"\n"
	"								dialogBuffer.AddText(\" \");\n"
	"								dialogBuffer.Skip();\n"
	"							}\n"
	"\n"
	"							if (selectedOption.text != undefined) {\n"
	"								dialogBuffer.AddText(selectedOption.text);\n"
	"								dialogBuffer.Skip();\n"
	"							}\n"
	"						}\n"
	"\n"
	"						dialogBuffer.AddText(\" >\");\n"
	"						dialogBuffer.Skip();\n"
	"					}\n"
	"					else {\n"
	"						dialogBuffer.AddText(\"(\" + control.value + \")\");\n"
	"						dialogBuffer.Skip();\n"
	"					}\n"
	"				}\n"
	"\n"
	"				if (control.control === \"toggle\" && control.checked != undefined && control.checked) {\n"
	"					dialogBuffer.AddText(\" ]\");\n"
	"					dialogBuffer.Skip();\n"
	"				}\n"
	"\n"
	"				dialogBuffer.AddLinebreak();\n"
	"				dialogBuffer.Skip();\n"
	"			}\n"
	"		}\n"
	"\n"
	"		// update text rendering\n"
	"		if (dialogBuffer.IsActive()) {\n"
	"			dialogRenderer.Draw(dialogBuffer, dt);\n"
	"			dialogBuffer.Update(dt);\n"
	"		}\n"
	"	}\n"
	"\n"
	"	// update tool main loop\n"
	"	if (tool.loop) {\n"
	"		tool.loop(dt);\n"
	"	}\n"
	"\n"
	"	// TODO : need a new way to quit the tool demo now that I'm using the menu button for this\n"
	"	if (bitsy.button(bitsy.BTN_MENU) && !isMenuButtonHeld) {\n"
	"		isMenuActive = !isMenuActive;\n"
	"\n"
	"		menuControls = [];\n"
	"\n"
	"		// reset dialog buffer (is this necessary?)\n"
	"		dialogRenderer.Reset();\n"
	"		dialogRenderer.SetCentered(true);\n"
	"		dialogBuffer.Reset();\n"
	"\n"
	"		// kind of a hack to just directly change textbox rendering state...\n"
	"		bitsy.textbox(isMenuActive);\n"
	"	}\n"
	"\n"
	"	isUpButtonHeld = bitsy.button(bitsy.BTN_UP);\n"
	"	isDownButtonHeld = bitsy.button(bitsy.BTN_DOWN);\n"
	"	isLeftButtonHeld = bitsy.button(bitsy.BTN_LEFT);\n"
	"	isRightButtonHeld = bitsy.button(bitsy.BTN_RIGHT);\n"
	"	isOkButtonHeld = bitsy.button(bitsy.BTN_OK);\n"
	"	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);\n"
	"});\n";

#endif